diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' binutils-2.42/autom4te.cache/traces.0t binutils-new/autom4te.cache/traces.0t
--- binutils-2.42/autom4te.cache/traces.0t	1969-12-31 16:00:00.000000000 -0800
+++ binutils-new/autom4te.cache/traces.0t	2024-07-02 10:41:12.665646502 -0700
@@ -0,0 +1,163 @@
+m4trace:configure.ac:22: -1- m4_include([config/acx.m4])
+m4trace:configure.ac:23: -1- m4_include([config/override.m4])
+m4trace:configure.ac:24: -1- m4_include([config/proginstall.m4])
+m4trace:configure.ac:25: -1- m4_include([config/elf.m4])
+m4trace:configure.ac:26: -1- m4_include([config/ax_cxx_compile_stdcxx.m4])
+m4trace:configure.ac:27: -1- m4_include([config/gcc-plugin.m4])
+m4trace:configure.ac:28: -1- m4_include([libtool.m4])
+m4trace:configure.ac:29: -1- m4_include([ltoptions.m4])
+m4trace:configure.ac:30: -1- m4_include([ltsugar.m4])
+m4trace:configure.ac:31: -1- m4_include([ltversion.m4])
+m4trace:configure.ac:32: -1- m4_include([lt~obsolete.m4])
+m4trace:configure.ac:33: -1- m4_include([config/isl.m4])
+m4trace:configure.ac:35: -1- AC_INIT([move-if-change])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([^_?A[CHUM]_])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([_AC_])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([^LIBOBJS$], [do not use LIBOBJS directly, use AC_LIBOBJ (see section 'AC_LIBOBJ vs LIBOBJS'])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^AS_FLAGS$])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([^_?m4_])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([^dnl$])
+m4trace:configure.ac:35: -1- m4_pattern_forbid([^_?AS_])
+m4trace:configure.ac:35: -1- AC_SUBST([SHELL])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([SHELL])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^SHELL$])
+m4trace:configure.ac:35: -1- AC_SUBST([PATH_SEPARATOR])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PATH_SEPARATOR])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PATH_SEPARATOR$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_NAME], [m4_ifdef([AC_PACKAGE_NAME],      ['AC_PACKAGE_NAME'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_NAME])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_NAME$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_TARNAME], [m4_ifdef([AC_PACKAGE_TARNAME],   ['AC_PACKAGE_TARNAME'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_TARNAME])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_VERSION], [m4_ifdef([AC_PACKAGE_VERSION],   ['AC_PACKAGE_VERSION'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_VERSION])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_VERSION$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_STRING], [m4_ifdef([AC_PACKAGE_STRING],    ['AC_PACKAGE_STRING'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_STRING])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_STRING$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_BUGREPORT], [m4_ifdef([AC_PACKAGE_BUGREPORT], ['AC_PACKAGE_BUGREPORT'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_BUGREPORT])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
+m4trace:configure.ac:35: -1- AC_SUBST([PACKAGE_URL], [m4_ifdef([AC_PACKAGE_URL],       ['AC_PACKAGE_URL'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([PACKAGE_URL])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_URL$])
+m4trace:configure.ac:35: -1- AC_SUBST([exec_prefix], [NONE])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([exec_prefix])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^exec_prefix$])
+m4trace:configure.ac:35: -1- AC_SUBST([prefix], [NONE])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([prefix])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^prefix$])
+m4trace:configure.ac:35: -1- AC_SUBST([program_transform_name], [s,x,x,])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([program_transform_name])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^program_transform_name$])
+m4trace:configure.ac:35: -1- AC_SUBST([bindir], ['${exec_prefix}/bin'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([bindir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^bindir$])
+m4trace:configure.ac:35: -1- AC_SUBST([sbindir], ['${exec_prefix}/sbin'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([sbindir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^sbindir$])
+m4trace:configure.ac:35: -1- AC_SUBST([libexecdir], ['${exec_prefix}/libexec'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([libexecdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^libexecdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([datarootdir], ['${prefix}/share'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([datarootdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^datarootdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([datadir], ['${datarootdir}'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([datadir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^datadir$])
+m4trace:configure.ac:35: -1- AC_SUBST([sysconfdir], ['${prefix}/etc'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([sysconfdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^sysconfdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([sharedstatedir], ['${prefix}/com'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([sharedstatedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^sharedstatedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([localstatedir], ['${prefix}/var'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([localstatedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^localstatedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([runstatedir], ['${localstatedir}/run'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([runstatedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^runstatedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([includedir], ['${prefix}/include'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([includedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^includedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([oldincludedir], ['/usr/include'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([oldincludedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^oldincludedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([docdir], [m4_ifset([AC_PACKAGE_TARNAME],
+				     ['${datarootdir}/doc/${PACKAGE_TARNAME}'],
+				     ['${datarootdir}/doc/${PACKAGE}'])])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([docdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^docdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([infodir], ['${datarootdir}/info'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([infodir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^infodir$])
+m4trace:configure.ac:35: -1- AC_SUBST([htmldir], ['${docdir}'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([htmldir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^htmldir$])
+m4trace:configure.ac:35: -1- AC_SUBST([dvidir], ['${docdir}'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([dvidir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^dvidir$])
+m4trace:configure.ac:35: -1- AC_SUBST([pdfdir], ['${docdir}'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([pdfdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^pdfdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([psdir], ['${docdir}'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([psdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^psdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([libdir], ['${exec_prefix}/lib'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([libdir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^libdir$])
+m4trace:configure.ac:35: -1- AC_SUBST([localedir], ['${datarootdir}/locale'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([localedir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^localedir$])
+m4trace:configure.ac:35: -1- AC_SUBST([mandir], ['${datarootdir}/man'])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([mandir])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^mandir$])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_NAME])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_NAME$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_NAME], [/* Define to the full name of this package. */
+@%:@undef PACKAGE_NAME])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_TARNAME])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_TARNAME$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_TARNAME], [/* Define to the one symbol short name of this package. */
+@%:@undef PACKAGE_TARNAME])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_VERSION])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_VERSION$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_VERSION], [/* Define to the version of this package. */
+@%:@undef PACKAGE_VERSION])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_STRING])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_STRING$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_STRING], [/* Define to the full name and version of this package. */
+@%:@undef PACKAGE_STRING])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_BUGREPORT])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_BUGREPORT], [/* Define to the address where bug reports for this package should be sent. */
+@%:@undef PACKAGE_BUGREPORT])
+m4trace:configure.ac:35: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_URL])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^PACKAGE_URL$])
+m4trace:configure.ac:35: -1- AH_OUTPUT([PACKAGE_URL], [/* Define to the home page for this package. */
+@%:@undef PACKAGE_URL])
+m4trace:configure.ac:35: -1- AC_SUBST([DEFS])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([DEFS])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^DEFS$])
+m4trace:configure.ac:35: -1- AC_SUBST([ECHO_C])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([ECHO_C])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^ECHO_C$])
+m4trace:configure.ac:35: -1- AC_SUBST([ECHO_N])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([ECHO_N])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^ECHO_N$])
+m4trace:configure.ac:35: -1- AC_SUBST([ECHO_T])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([ECHO_T])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^ECHO_T$])
+m4trace:configure.ac:35: -1- AC_SUBST([LIBS])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([LIBS])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^LIBS$])
+m4trace:configure.ac:35: -1- AC_SUBST([build_alias])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([build_alias])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^build_alias$])
+m4trace:configure.ac:35: -1- AC_SUBST([host_alias])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([host_alias])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^host_alias$])
+m4trace:configure.ac:35: -1- AC_SUBST([target_alias])
+m4trace:configure.ac:35: -1- AC_SUBST_TRACE([target_alias])
+m4trace:configure.ac:35: -1- m4_pattern_allow([^target_alias$])
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' binutils-2.42/gas/config/tc-arm.c binutils-new/gas/config/tc-arm.c
--- binutils-2.42/gas/config/tc-arm.c	2024-01-28 16:00:00.000000000 -0800
+++ binutils-new/gas/config/tc-arm.c	2024-07-03 10:01:53.296710411 -0700
@@ -27793,29 +27793,29 @@
   start_unwind_section (now_seg, 0);
 
   if (unwind.personality_routine == NULL)
-    {
-      if (unwind.personality_index == -2)
-	{
-	  if (have_data)
+  {
+    if (unwind.personality_index == -2)
+	 {
+	   if (have_data)
 	    as_bad (_("handlerdata in cantunwind frame"));
-	  return 1; /* EXIDX_CANTUNWIND.  */
-	}
+	   return 1; /* EXIDX_CANTUNWIND.  */
+	 }
 
       /* Use a default personality routine if none is specified.  */
-      if (unwind.personality_index == -1)
-	{
-	  if (unwind.opcode_count > 3)
-	    unwind.personality_index = 1;
-	  else
-	    unwind.personality_index = 0;
-	}
+    if (unwind.personality_index == -1)
+	  {
+	     if (unwind.opcode_count > 3)
+	       unwind.personality_index = 1;
+	     else
+	       unwind.personality_index = 0;
+	  }
 
       /* Space for the personality routine entry.  */
-      if (unwind.personality_index == 0)
-	{
-	  if (unwind.opcode_count > 3)
+    if (unwind.personality_index == 0)
+    {
+      if (unwind.opcode_count > 3)
 	    {
-	      as_bad (_("too many unwind opcodes for personality routine 0"));
+        as_bad (_("too many unwind opcodes for personality routine 0"));
 	      return 1;
 	    }
 
@@ -27825,15 +27825,15 @@
 	      data = 0x80;
 	      n = 3;
 	      while (unwind.opcode_count > 0)
-		{
-		  unwind.opcode_count--;
-		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
-		  n--;
-		}
+		    {
+    		  unwind.opcode_count--;
+    		  data = (data << 8) | unwind.opcodes[unwind.opcode_count];
+    		  n--;
+		    }
 
 	      /* Pad with "finish" opcodes.  */
 	      while (n--)
-		data = (data << 8) | 0xb0;
+		      data = (data << 8) | 0xb0;
 
 	      return data;
 	    }
@@ -27842,7 +27842,7 @@
       else
 	/* We get two opcodes "free" in the first word.	 */
 	size = unwind.opcode_count - 2;
-    }
+  }
   else
     {
       /* PR 16765: Missing or misplaced unwind directives can trigger this.  */
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' binutils-2.42/gas/config/tc-avr.c binutils-new/gas/config/tc-avr.c
--- binutils-2.42/gas/config/tc-avr.c	2024-01-28 16:00:00.000000000 -0800
+++ binutils-new/gas/config/tc-avr.c	2024-07-05 09:24:49.550578599 -0700
@@ -28,6 +28,9 @@
 #include "elf/avr.h"
 #include "elf32-avr.h"
 
+#define streq(a, b)       (strcmp (a, b) == 0)
+#define FAIL (-1)
+
 /* For building a linked list of AVR_PROPERTY_RECORD structures.  */
 struct avr_property_record_link
 {
@@ -483,13 +486,37 @@
 
 static void avr_set_arch (int);
 
+/* Unwind stuff */
+static void create_unwind_entry (void);
+static void s_avr_unwind_fnstart(int);
+static void s_avr_unwind_fnend (int);
+static void finish_unwind_opcodes (void);
+static void flush_pending_unwind (void);
+static void add_unwind_adjustsp (offsetT);
+static void add_unwind_opcode (valueT op);
+static void s_avr_unwind_pad (int);
+static void s_avr_unwind_save (int);
+static void s_avr_unwind_personality (int);
+static void s_avr_unwind_setfp(int);
+static void s_arm_unwind_cantunwind(int);
+static void s_avr_unwind_handlerdata (int);
+
 /* The target specific pseudo-ops which we support.  */
 const pseudo_typeS md_pseudo_table[] =
 {
   {"arch", avr_set_arch,	0},
+  { "fnstart",    s_avr_unwind_fnstart, 0 },
+  { "fnend",    s_avr_unwind_fnend, 0 },
+  { "cantunwind", s_arm_unwind_cantunwind, 0 },
+  { "save",   s_avr_unwind_save,  0 },
+  { "pad",    s_avr_unwind_pad, 0 },
+  { "setfp",    s_avr_unwind_setfp, 0 },
+  { "handlerdata",  s_avr_unwind_handlerdata, 0 },
+  { "personality",  s_avr_unwind_personality, 0 },
   { NULL,	NULL,		0}
 };
 
+
 #define LDI_IMMEDIATE(x) (((x) & 0xf) | (((x) << 4) & 0xf00))
 
 #define EXP_MOD_NAME(i)       exp_mod[i].name
@@ -2846,3 +2873,419 @@
 
   return true;
 }
+
+
+
+static struct
+{
+  symbolS *   proc_start;
+  symbolS *   table_entry;
+  symbolS *   personality_routine;
+  symbolS *   personality_data;
+  /* The segment containing the function.  */
+  segT      saved_seg;
+  subsegT   saved_subseg;
+  /* Opcodes generated from this function.  */
+  unsigned char * opcodes;
+  int     opcode_count;
+  int     opcode_alloc;
+  /* The number of bytes pushed to the stack.  */
+  offsetT   frame_size;
+  /* We don't add stack adjustment opcodes immediately so that we can merge
+     multiple adjustments.  We can also omit the final adjustment
+     when using a frame pointer.  */
+  offsetT   pending_offset;
+  /* These two fields are set by both unwind_movsp and unwind_setfp.  They
+     hold the reg+offset to use when restoring sp from a frame pointer.  */
+  offsetT   fp_offset;
+  int     fp_reg;
+  /* Nonzero if an unwind_setfp directive has been seen.  */
+  unsigned    fp_used:1;
+  /* Nonzero if the last opcode restores sp from fp_reg.  */
+  unsigned    sp_restored:1;
+  unsigned cant_unwind: 1;
+} unwind;
+
+
+static void
+flush_pending_unwind (void)
+{
+  offsetT offset;
+
+  offset = unwind.pending_offset;
+  unwind.pending_offset = 0;
+  if (offset != 0)
+    add_unwind_adjustsp (offset);
+}
+
+static void
+add_unwind_adjustsp (offsetT offset)
+{
+  if(offset == 0) return;
+  while(offset >= 0x7F) {
+    add_unwind_opcode(0x7f);
+    offset -= 0x7f;
+  }
+  add_unwind_opcode(offset);
+}
+
+static void
+finish_unwind_opcodes (void)
+{
+  flush_pending_unwind ();
+}
+
+static int
+immediate_for_directive (int *val)
+{
+  expressionS exp;
+  exp.X_op = O_illegal;
+
+  expression (&exp);
+
+  if (exp.X_op != O_constant)
+    {
+      as_bad (_("expected a constant"));
+      ignore_rest_of_line ();
+      return FAIL;
+    }
+  *val = exp.X_add_number;
+  return 0;
+}
+
+static void
+start_unwind_section (const segT text_seg, int idx)
+{
+  const char * text_name;
+  const char * prefix;
+  const char * prefix_once;
+  struct elf_section_match match;
+  char * sec_name;
+  int type;
+  int flags;
+  int linkonce;
+
+  if (idx)
+    {
+      prefix = ELF_STRING_AVR_unwind_info;
+      prefix_once = ELF_STRING_AVR_unwind_info_once;
+      type = SHT_PROGBITS;
+    }
+  else
+    {
+      prefix = ELF_STRING_AVR_unwind_data;
+      prefix_once = ELF_STRING_AVR_unwind_data_once;
+      type = SHT_PROGBITS;
+    }
+
+  text_name = segment_name (text_seg);
+  if (streq (text_name, ".text"))
+    text_name = "";
+
+  if (startswith (text_name, ".gnu.linkonce.t."))
+    {
+      prefix = prefix_once;
+      text_name += strlen (".gnu.linkonce.t.");
+    }
+
+  sec_name = concat (prefix, text_name, (char *) NULL);
+
+  flags = SHF_ALLOC;
+  linkonce = 0;
+  memset (&match, 0, sizeof (match));
+
+  /* Handle COMDAT group.  */
+  if (prefix != prefix_once && (text_seg->flags & SEC_LINK_ONCE) != 0)
+    {
+      match.group_name = elf_group_name (text_seg);
+      if (match.group_name == NULL)
+  {
+    as_bad (_("Group section `%s' has no group signature"),
+      segment_name (text_seg));
+    ignore_rest_of_line ();
+    return;
+  }
+      flags |= SHF_GROUP;
+      linkonce = 1;
+    }
+
+  obj_elf_change_section (sec_name, type, flags, 0, &match,
+        linkonce);
+
+  /* Set the section link for index tables.  */
+  if (idx)
+    elf_linked_to_section (now_seg) = text_seg;
+}
+
+static void
+add_unwind_opcode (valueT op)
+{
+  /* Add any deferred stack adjustment.  */
+  if (unwind.pending_offset)
+    flush_pending_unwind ();
+
+  unwind.sp_restored = 0;
+
+  if (unwind.opcode_count + 1 > unwind.opcode_alloc)
+    {
+      unwind.opcode_alloc += 16;
+      if (unwind.opcodes)
+  unwind.opcodes = XRESIZEVEC (unsigned char, unwind.opcodes,
+             unwind.opcode_alloc);
+      else
+  unwind.opcodes = XNEWVEC (unsigned char, unwind.opcode_alloc);
+    }
+  unwind.opcodes[unwind.opcode_count] = op;
+  unwind.opcode_count++;
+    
+}
+
+static void
+s_avr_unwind_pad (int ignored ATTRIBUTE_UNUSED)
+{
+  int offset;
+
+  if (!unwind.proc_start)
+    as_bad (_("missing .fnstart before unwinding directive"));
+
+  if (immediate_for_directive (&offset) == FAIL)
+    return;
+
+  /* Don't generate any opcodes, just record the details for later.  */
+  unwind.frame_size += offset;
+  unwind.pending_offset += offset;
+
+  demand_empty_rest_of_line ();
+}
+
+static void s_avr_unwind_setfp(int ignored ATTRIBUTE_UNUSED){
+  if (!unwind.proc_start)
+    as_bad (_("missing .fnstart before unwinding directive"));
+
+  if (immediate_for_directive (&unwind.fp_reg) == FAIL)
+    return;
+  demand_empty_rest_of_line ();
+}
+
+static int
+avr_parse_reg (char **ccp)
+{
+  char *start = *ccp;
+  char *p;
+  int reg = 0;
+
+  start = skip_space (start);
+
+  if (*start == 'r')
+    start++;
+#ifdef OPTIONAL_REGISTER_PREFIX
+  if (*start == OPTIONAL_REGISTER_PREFIX)
+    start++;
+#endif
+
+  reg = strtoul(start, &p, 10);
+  if(p == start) return -1;
+
+  *ccp = p;
+  return reg;
+}
+
+static char is_callee_saved(unsigned reg){
+  if(specified_mcu.isa == AVR_ISA_AVRTINY){
+    if(reg < 18) return 0;
+    if(reg > 19 && reg < 28) return 0;
+    if(reg > 29) return 0;
+    return 1;
+  }
+
+  if(reg <= 1) return 0;
+  if(reg >= 18 && reg <= 27) return 0;
+  if(reg >= 30) return 0;
+  return 1;
+}
+
+static void
+s_avr_unwind_save (int ignored ATTRIBUTE_UNUSED)
+{
+  int reg;
+
+  flush_pending_unwind();
+
+  if (!unwind.proc_start)
+    as_bad (_("Missing .fnstart"));
+
+  /* Figure out what sort of save we have.  */
+
+  reg = avr_parse_reg (&input_line_pointer);
+
+  if(reg == -1)
+    as_bad (_("Invalid register constant"));
+
+  if(!is_callee_saved(reg)){
+    fprintf(stderr, "invalid reg: %u\n", reg);
+    as_bad (_("Cannot save call-clobbered register"));
+  }
+
+  if (reg < 18) {
+    reg -= 2;
+  } else {
+    reg -= 12;
+  }
+
+  add_unwind_opcode(reg | 0x80);
+}
+
+
+static void
+s_avr_unwind_personality (int ignored ATTRIBUTE_UNUSED)
+{
+  char *name, *p, c;
+
+  if (!unwind.proc_start)
+    as_bad (_("Missing .fnstart"));
+
+  if (unwind.personality_routine)
+    as_bad (_("duplicate .personality directive"));
+
+  c = get_symbol_name (& name);
+  p = input_line_pointer;
+  if (c == '"')
+    ++ input_line_pointer;
+  unwind.personality_routine = symbol_find_or_make (name);
+  *p = c;
+  demand_empty_rest_of_line ();
+}
+
+
+static void
+s_avr_unwind_handlerdata (int ignored ATTRIBUTE_UNUSED)
+{
+  demand_empty_rest_of_line ();
+  if (!unwind.proc_start)
+    as_bad (_("Missing .fnstart directive"));
+
+  if (unwind.personality_data)
+    as_bad (_("duplicate .handlerdata directive"));
+
+  unwind.personality_data = expr_build_dot();
+}
+
+
+static void s_arm_unwind_cantunwind(int){
+  unwind.cant_unwind = 1;
+  demand_empty_rest_of_line ();
+}
+
+static void
+create_unwind_entry ()
+{
+  char *ptr;
+
+  finish_unwind_opcodes ();
+
+  /* Remember the current text section.  */
+  unwind.saved_seg = now_seg;
+  unwind.saved_subseg = now_subseg;
+
+  start_unwind_section (now_seg, 0);
+
+  unwind.table_entry = expr_build_dot ();
+
+  ptr = frag_more (unwind.opcode_count);
+  memcpy(ptr, unwind.opcodes, unwind.opcode_count);
+}
+
+static void
+s_avr_unwind_fnstart (int ignored ATTRIBUTE_UNUSED)
+{
+  demand_empty_rest_of_line ();
+  if (unwind.proc_start)
+    {
+      as_bad (_("duplicate .fnstart directive"));
+      return;
+    }
+
+  /* Mark the start of the function.  */
+  unwind.proc_start = expr_build_dot ();
+
+  /* Reset the rest of the unwind info.  */
+  unwind.opcode_count = 0;
+  unwind.table_entry = NULL;
+  unwind.personality_routine = NULL;
+  unwind.personality_data = NULL;
+  unwind.frame_size = 0;
+  unwind.fp_offset = 0;
+  unwind.fp_reg = 0;
+  unwind.fp_used = 0;
+  unwind.sp_restored = 0;
+  unwind.cant_unwind = 0;
+}
+
+
+
+static void
+s_avr_unwind_fnend (int ignored ATTRIBUTE_UNUSED)
+{
+  long where;
+  char *ptr;
+
+  symbolS* function_end = expr_build_dot ();
+
+  demand_empty_rest_of_line ();
+
+  if (!unwind.proc_start)
+    {
+      as_bad (_(".fnend directive without .fnstart"));
+      return;
+    }
+
+  if(unwind.cant_unwind && ! unwind.personality_data){
+    goto end;
+  }
+
+  create_unwind_entry();
+
+  /* Add index table entry.  This is two words.  */
+  start_unwind_section (unwind.saved_seg, 1);
+
+  ptr = frag_more (10);
+  memset (ptr, 0, 10);
+  where = frag_now_fix () - 10;
+
+  /* function start.  */
+  fix_new (frag_now, where, 2, unwind.proc_start, 0, 0,
+     BFD_RELOC_AVR_16_PM);
+  /* function end */
+  fix_new (frag_now, where + 2, 2, function_end, 0, 0,
+     BFD_RELOC_AVR_16_PM);
+
+    /* offset of the table entry.  */
+  if(! unwind.cant_unwind){
+  fix_new (frag_now, where + 4, 2, unwind.table_entry, 0, 0,
+     BFD_RELOC_16);
+  }else{
+    ptr[4] = 0xff;
+    ptr[5] = 0xff;
+  }
+
+  // length of section
+  ptr[6] = unwind.fp_reg;
+  if(unwind.opcode_count > 255)
+    as_bad(_("fae_data section is too large!"));
+  ptr[7] = unwind.opcode_count;
+
+  if(unwind.personality_data){
+    fix_new (frag_now, where + 8, 1, unwind.personality_data, 0, 1,
+       BFD_RELOC_AVR_8_LO);
+    fix_new (frag_now, where + 9, 1, unwind.personality_data, 0, 1,
+       BFD_RELOC_AVR_8_HI);
+  }
+
+
+  /* Restore the original section.  */
+  subseg_set (unwind.saved_seg, unwind.saved_subseg);
+
+end:
+  unwind.proc_start = NULL;
+}
+
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' binutils-2.42/include/elf/avr.h binutils-new/include/elf/avr.h
--- binutils-2.42/include/elf/avr.h	2024-01-28 16:00:00.000000000 -0800
+++ binutils-new/include/elf/avr.h	2024-07-01 15:28:31.540229137 -0700
@@ -49,6 +49,13 @@
 #define E_AVR_MACH_XMEGA6  106
 #define E_AVR_MACH_XMEGA7  107
 
+/* EH section names */
+#define ELF_STRING_AVR_unwind_info           ".fae_info"
+#define ELF_STRING_AVR_unwind_data           ".fae_data"
+#define ELF_STRING_AVR_unwind_info_once      ".gnu.linkonce.fae_info."
+#define ELF_STRING_AVR_unwind_data_once      ".gnu.linkonce.fae_data."
+
+
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_avr_reloc_type)
      RELOC_NUMBER (R_AVR_NONE,			0)
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' binutils-2.42/ld/scripttempl/avr.sc binutils-new/ld/scripttempl/avr.sc
--- binutils-2.42/ld/scripttempl/avr.sc	2024-01-28 16:00:00.000000000 -0800
+++ binutils-new/ld/scripttempl/avr.sc	2024-07-03 07:18:29.857432322 -0700
@@ -206,7 +206,6 @@
     *libc.a:*(.progmem.data)
 
     *(.progmem.*)
-
     . = ALIGN(2);
 
     /* For code that needs to reside in the lower 128k progmem.  */
@@ -282,7 +281,16 @@
     *(.jumptables)
     *(.jumptables*)
 
-    _etext = . ;}
+    _etext = .;
+    PROVIDE (__lsda_begin = .) ; 
+    *(.gcc_except_table)
+    *(.gcc_except_table.*)
+    PROVIDE (__fae_table_start = .) ;
+    KEEP(*(.fae_info))
+    KEEP(*(.fae_info.*))
+    PROVIDE (__fae_table_stop = .) ; ;}
+    KEEP(*(.fae_data))
+    KEEP(*(.fae_data.*))
   } ${RELOCATING+ > text}
 EOF
 
