diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/common/config/avr/avr-common.cc gcc-new/gcc/common/config/avr/avr-common.cc
--- gcc-13.2.0/gcc/common/config/avr/avr-common.cc	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/common/config/avr/avr-common.cc	2024-07-01 10:42:04.675809016 -0700
@@ -141,6 +141,16 @@
 }
 
 
+enum unwind_info_type
+avr_except_unwind_info (struct gcc_options *opts)
+{
+  if (!opts->x_flag_exceptions && !opts->x_flag_unwind_tables)
+return UI_NONE;
+  else
+return UI_TARGET;
+}
+
+
 #undef TARGET_HANDLE_OPTION
 #define TARGET_HANDLE_OPTION avr_handle_option
 
@@ -148,6 +158,6 @@
 #define TARGET_OPTION_OPTIMIZATION_TABLE avr_option_optimization_table
 
 #undef TARGET_EXCEPT_UNWIND_INFO
-#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info
+#define TARGET_EXCEPT_UNWIND_INFO avr_except_unwind_info
 
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/config/avr/avr.cc gcc-new/gcc/config/avr/avr.cc
--- gcc-13.2.0/gcc/config/avr/avr.cc	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/config/avr/avr.cc	2024-07-06 07:39:45.744748972 -0700
@@ -1467,6 +1467,270 @@
 }
 
 
+/* Implement ASM_DECLARE_FUNCTION_NAME on AVR */
+
+void
+avr_asm_declare_function_name (FILE *file, const char *name, tree)
+{
+  ASM_OUTPUT_TYPE_DIRECTIVE (file, name, "function");
+  ASM_OUTPUT_LABEL (file, name);
+
+  AVR_OUTPUT_FN_UNWIND (file, TRUE);
+}
+
+
+/* Emit unwind information for AVR */
+void
+avr_output_fn_unwind (FILE * f, bool prologue)
+{
+  if (avr_except_unwind_info (&global_options) != UI_TARGET)
+    return;
+
+  if (prologue)
+    fputs ("\t.fnstart\n", f);
+  else
+    {
+      /* If this function will never be unwound, then mark it as such.
+         The came condition is used in arm_unwind_emit to suppress
+   the frame annotations.  */
+      if (!(flag_unwind_tables || crtl->uses_eh_lsda)
+    && (TREE_NOTHROW (current_function_decl)
+        || crtl->all_throwers_are_sibcalls))
+  fputs("\t.cantunwind\n", f);
+
+      fputs ("\t.fnend\n", f);
+    }
+}
+
+/*  Emit unwind directives for a SET.  */
+
+static void
+avr_unwind_emit_set (FILE * out_file, rtx p)
+{
+  rtx e0;
+  rtx e1;
+  unsigned reg;
+
+  e0 = XEXP (p, 0);
+  e1 = XEXP (p, 1);
+  switch (GET_CODE (e0))
+  {
+    case MEM:
+      /* Pushing a single register.  */
+      if (GET_CODE (XEXP (e0, 0)) != POST_DEC
+        || !REG_P (XEXP (XEXP (e0, 0), 0))
+        || REGNO (XEXP (XEXP (e0, 0), 0)) != REG_SP)
+          abort ();
+
+      asm_fprintf (out_file, "\t.save %R%u\n", REGNO (e1));
+      // asm_fprintf(out_file, "%R%u\n", REGNO (e1));
+          break;
+
+    case REG:
+      if (REGNO (e0) == REG_SP)
+      {
+        /* A stack increment.  */
+        if (GET_CODE (e1) != PLUS
+            || !REG_P (XEXP (e1, 0))
+            || REGNO (XEXP (e1, 0)) != REG_SP
+            || !CONST_INT_P (XEXP (e1, 1)))
+          abort ();
+
+        asm_fprintf (out_file, "\t.pad %wd\n",
+               -INTVAL (XEXP (e1, 1)));
+      }
+      else if (REGNO (e0) == HARD_FRAME_POINTER_REGNUM)
+      {
+        HOST_WIDE_INT offset;
+
+        if (GET_CODE (e1) == PLUS)
+          {
+            if (!REG_P (XEXP (e1, 0))
+              || !CONST_INT_P (XEXP (e1, 1)))
+              abort ();
+            reg = REGNO (XEXP (e1, 0));
+            offset = INTVAL (XEXP (e1, 1));
+            asm_fprintf (out_file, "\t.setfp %r, %r, #%wd\n",
+             HARD_FRAME_POINTER_REGNUM, reg,
+             offset);
+          }
+        else if (REG_P (e1))
+          {
+            reg = REGNO (e1);
+            asm_fprintf (out_file, "\t.setfp %r, %r\n",
+             HARD_FRAME_POINTER_REGNUM, reg);
+          }
+        else
+          abort ();
+      }
+      else if (REG_P (e1) && REGNO (e1) == REG_SP)
+      {
+        /* Move from sp to reg.  */
+        asm_fprintf (out_file, "\t.movsp %r\n", REGNO (e0));
+      }
+      else if (GET_CODE (e1) == PLUS
+        && REG_P (XEXP (e1, 0))
+        && REGNO (XEXP (e1, 0)) == REG_SP
+        && CONST_INT_P (XEXP (e1, 1)))
+      {
+        /* Set reg to offset from sp.  */
+        asm_fprintf (out_file, "\t.movsp %r, #%d\n",
+               REGNO (e0), (int)INTVAL(XEXP (e1, 1)));
+      }
+      else
+        abort ();
+      break;
+
+    default:
+      abort ();
+  }
+}
+
+
+
+/* This function includes a lot of defensive programming, which
+   really should be moved to a unit test out of the main program. */
+static void
+avr_unwind_emit (FILE * out_file, rtx_insn *insn)
+{
+  rtx note, pat;
+  bool handled_one = false;
+  int last_offset = 1;
+
+  if (avr_except_unwind_info (&global_options) != UI_TARGET)
+    return;
+
+  if (!(flag_unwind_tables || crtl->uses_eh_lsda)
+      && (TREE_NOTHROW (current_function_decl)
+    || crtl->all_throwers_are_sibcalls))
+    return;
+
+  if (NOTE_P (insn) || !RTX_FRAME_RELATED_P (insn))
+    return;
+
+  for (note = REG_NOTES (insn); note ; note = XEXP (note, 1))
+    {
+      switch (REG_NOTE_KIND (note))
+  {
+  case REG_FRAME_RELATED_EXPR:
+    pat = XEXP (note, 0);
+    goto found;
+
+  case REG_CFA_REGISTER:
+    pat = XEXP (note, 0);
+    if (pat == NULL)
+      {
+        pat = PATTERN (insn);
+        if (GET_CODE (pat) == PARALLEL)
+          pat = XVECEXP (pat, 0, 0);
+      }
+
+    /* Only emitted for IS_STACKALIGN re-alignment.  */
+    {
+      rtx dest, src;
+      unsigned reg;
+
+      src = SET_SRC (pat);
+      dest = SET_DEST (pat);
+
+      gcc_assert (src == stack_pointer_rtx);
+      reg = REGNO (dest);
+
+        asm_fprintf (out_file, "\t.unwind_raw 0, 0x%x @ vsp = r%d\n",
+         reg + 0x90, reg);
+    }
+    handled_one = true;
+    break;
+
+  /* The INSN is generated in epilogue.  It is set as RTX_FRAME_RELATED_P
+     to get correct dwarf information for shrink-wrap.  We should not
+     emit unwind information for it because these are used either for
+     pretend arguments or notes to adjust sp and restore registers from
+     stack.  */
+  case REG_CFA_ADJUST_CFA:
+    {
+      pat = XEXP(note, 0);
+      if(GET_CODE(pat) != SET)
+        gcc_unreachable();
+      // r28 is literally the only base pointer allowed,
+      // and because of how AVR does things a base pointer
+      // is always necessary when adjusting the sp, so
+      // this is always true
+      asm_fprintf (out_file, "\t.setfp 28\n");
+
+      rtx e1 = XEXP(pat, 1);
+      if(GET_CODE(e1) != PLUS)
+        return;
+      rtx e1_1 = XEXP(e1, 1);
+      long stack_size = XINT(e1_1, 0);
+      if(stack_size > 0)
+        gcc_unreachable();
+      asm_fprintf (out_file, "\t.pad %ld\n", -stack_size + (last_offset-1));
+      return;
+    }
+  case REG_CFA_OFFSET:{
+      pat = XEXP(note, 0);
+      if(GET_CODE (pat) != SET)
+        gcc_unreachable();
+      rtx e0 = XEXP(pat, 0);
+      rtx e0_0 = XEXP(e0, 0);
+      int offset;
+      if(GET_CODE(e0_0) == REG){
+        // checks if register is SP_L
+        if(XINT(e0_0, 0) != 32)
+          gcc_unreachable();
+        offset = 0;
+      }else if(GET_CODE(e0_0) == PLUS){
+        rtx addant = XEXP(e0_0, 1);
+        if(GET_CODE(addant) != CONST_INT)
+          gcc_unreachable();
+        offset = XINT(addant, 0);
+      }else{
+        gcc_unreachable();
+      }
+      rtx e1 = XEXP(pat, 1);
+      if(GET_CODE(e1) != REG)
+        gcc_unreachable();
+      int reg = XINT(e1, 0);
+      // maintains that registers in descending order
+      if(last_offset -1 != offset)
+        gcc_unreachable();
+      asm_fprintf (out_file, "\t.save %R%u\n", reg);
+      last_offset = offset;
+      continue;
+  }
+  case REG_CFA_DEF_CFA:
+  case REG_CFA_RESTORE:
+    return;
+
+  case REG_CFA_EXPRESSION:
+    /* ??? Only handling here what we actually emit.  */
+    gcc_unreachable ();
+
+  default:
+    break;
+  }
+    }
+  if (handled_one){
+      return;
+  }
+  pat = PATTERN (insn);
+ found:
+
+  switch (GET_CODE (pat))
+    {
+    case PARALLEL:
+      // ignore it and hope for the best
+      break;
+    case SET:
+      avr_unwind_emit_set (out_file, pat);
+      break;
+
+    default:
+      abort();
+    }
+}
+
 /* Implement `ACCUMULATE_OUTGOING_ARGS'.  */
 
 int
@@ -10725,6 +10989,12 @@
     readonly_data_section->unnamed.callback = avr_output_data_section_asm_op;
   data_section->unnamed.callback = avr_output_data_section_asm_op;
   bss_section->unnamed.callback = avr_output_bss_section_asm_op;
+
+  /* insert .handlerdata and personality directive */
+  exception_section = get_unnamed_section (0, output_section_asm_op,
+             "\t.personality __avr_cxx_personality\n"
+             "\t.section .gcc_except_table,\"a\",@progbits\n"
+             "\t.handlerdata");
 }
 
 
@@ -13521,6 +13791,16 @@
   return NULL_TREE;
 }
 
+/* Implements EH_RETURN_HANDLER_RTX */
+rtx
+avr_eh_return_handler_rtx (void)
+{
+  rtx tmp = avr_incoming_return_addr_rtx();
+
+  /* Mark the store volatile, so no optimization is permitted to remove it.  */
+  MEM_VOLATILE_P (tmp) = true;
+  return tmp;
+}
 
 /* Implement `TARGET_LEGITIMATE_COMBINED_INSN'.  */
 
@@ -15119,6 +15399,9 @@
 #undef  TARGET_ADDR_SPACE_DIAGNOSE_USAGE
 #define TARGET_ADDR_SPACE_DIAGNOSE_USAGE avr_addr_space_diagnose_usage
 
+#undef TARGET_ASM_UNWIND_EMIT
+#define TARGET_ASM_UNWIND_EMIT avr_unwind_emit
+
 #undef  TARGET_MODE_DEPENDENT_ADDRESS_P
 #define TARGET_MODE_DEPENDENT_ADDRESS_P avr_mode_dependent_address_p
 
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/config/avr/avr.h gcc-new/gcc/config/avr/avr.h
--- gcc-13.2.0/gcc/config/avr/avr.h	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/config/avr/avr.h	2024-07-02 13:50:50.879568104 -0700
@@ -386,6 +386,8 @@
    There are no shared libraries on this target, and these sections are
    placed in the read-only program memory, so they are not writable.  */
 
+#define INIT_SECTION_ASM_OP "\t.section\t.init"
+
 #undef CTORS_SECTION_ASM_OP
 #define CTORS_SECTION_ASM_OP "\t.section .ctors,\"a\",@progbits"
 
@@ -514,9 +516,6 @@
   " %:double-lib(%{m*:m%*})"                            \
   " %:device-specs-file(device-specs%s %{mmcu=*:%*})"
 
-/* No libstdc++ for now.  Empty string doesn't work.  */
-#define LIBSTDCXX "gcc"
-
 /* This is the default without any -mmcu=* option.  */
 #define MULTILIB_DEFAULTS { "mmcu=" AVR_MMCU_DEFAULT }
 
@@ -525,8 +524,19 @@
 
 #define CR_TAB "\n\t"
 
+/* Used to define how dwarf exception handling is implemented. */
+#define EH_RETURN_DATA_REGNO(N) ((26 - (N+1) * 2) >= 20 ? (26 - (N+1) * 2) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 24)
+  
+/* This might have to be changed to pcrel if the pointer is not big enough */
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)           (DW_EH_PE_absptr)
+#define EH_RETURN_HANDLER_RTX avr_eh_return_handler_rtx ()
+
+
 #define DWARF2_ADDR_SIZE 4
 
+#define AVR_OUTPUT_FN_UNWIND(F, PROLOGUE) avr_output_fn_unwind (F, PROLOGUE)
+
 #define INCOMING_RETURN_ADDR_RTX   avr_incoming_return_addr_rtx ()
 #define INCOMING_FRAME_SP_OFFSET   (AVR_3_BYTE_PC ? 3 : 2)
 
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/config/avr/avr-protos.h gcc-new/gcc/config/avr/avr-protos.h
--- gcc-13.2.0/gcc/config/avr/avr-protos.h	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/config/avr/avr-protos.h	2024-07-01 10:08:04.245972378 -0700
@@ -32,6 +32,10 @@
 extern void avr_register_target_pragmas (void);
 extern void avr_init_expanders (void);
 
+extern void avr_asm_declare_function_name (FILE *, const char *, tree);
+extern void avr_output_fn_unwind (FILE *, bool prologue);
+extern enum unwind_info_type avr_except_unwind_info (struct gcc_options *opts);
+
 #ifdef TREE_CODE
 extern void avr_asm_output_aligned_decl_common (FILE*, tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);
 extern void avr_asm_asm_output_aligned_bss (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int, void (*) (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int));
@@ -84,6 +88,7 @@
 
 extern void avr_expand_prologue (void);
 extern void avr_expand_epilogue (bool);
+extern rtx avr_eh_return_handler_rtx (void);
 extern bool avr_emit_cpymemhi (rtx*);
 extern int avr_epilogue_uses (int regno);
 
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/config/avr/elf.h gcc-new/gcc/config/avr/elf.h
--- gcc-13.2.0/gcc/config/avr/elf.h	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/config/avr/elf.h	2024-07-02 13:50:56.639567781 -0700
@@ -28,6 +28,16 @@
 #undef STRING_LIMIT
 #define STRING_LIMIT ((unsigned) 64)
 
+#undef  ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME avr_asm_declare_function_name
+#undef  ASM_DECLARE_FUNCTION_SIZE
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)     \
+  do                       \
+    {                      \
+      AVR_OUTPUT_FN_UNWIND (FILE, FALSE);       \
+      if (!flag_inhibit_size_directive)            \
+   ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);         \
+    }                      \
+  while (0)
 /* Be conservative in crtstuff.c.  */
-#undef INIT_SECTION_ASM_OP
-#undef FINI_SECTION_ASM_OP
+
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/gcc/config/avr/specs.h gcc-new/gcc/config/avr/specs.h
--- gcc-13.2.0/gcc/config/avr/specs.h	2023-07-27 01:13:04.000000000 -0700
+++ gcc-new/gcc/config/avr/specs.h	2024-06-29 15:42:10.616468437 -0700
@@ -78,3 +78,4 @@
 
 #define STARTFILE_SPEC ""
 #define ENDFILE_SPEC ""
+
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/config/avr/fae.h gcc-new/libgcc/config/avr/fae.h
--- gcc-13.2.0/libgcc/config/avr/fae.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libgcc/config/avr/fae.h	2024-07-06 07:53:15.024696697 -0700
@@ -0,0 +1,93 @@
+#pragma once
+
+typedef unsigned char uint8_t;
+typedef unsigned int uint16_t;
+typedef int int16_t;
+
+#ifdef __FLASH
+typedef const uint8_t __flash prog_byte;
+#define __maybe_flash __flash
+#else
+typedef const uint8_t prog_byte;
+#define __maybe_flash
+#endif
+
+
+typedef struct personality_out{
+  uint16_t landing_pad;
+} personality_out;
+
+typedef uint8_t (*personality_routine)(prog_byte *ptr, uint16_t pc_offset, void *exc,
+                           personality_out *lp_out);
+
+typedef struct table_entry_t {
+  uint16_t pc_begin;
+  uint16_t pc_end;
+  prog_byte *data;
+  uint8_t frame_reg;
+  uint8_t length;
+  prog_byte *lsda;
+  personality_routine personality;
+} table_entry_t;
+
+/* Entries are aligned by 2 so that personality_ptr
+   can be read by a single movw instruction. Pad
+    using 0x00. Entries may be null terminated to
+    simplify debugging */
+
+// 0x00 is padding byte, should only occur at the end of the entry.
+// high bit is 0
+typedef struct skip {
+  uint8_t bytes;
+} skip;
+// skip make_skip(uint8_t b){return skip{ b & ~0b10000000};}
+
+typedef enum reg : uint8_t {
+  r2,
+  r3,
+  r4,
+  r5,
+  r6,
+  r7,
+  r8,
+  r9,
+  r10,
+  r11,
+  r12,
+  r13,
+  r14,
+  r15,
+  r16,
+  r17,
+  r28,
+  r29
+} reg;
+
+// high bit is 1
+typedef struct pop {
+  uint8_t _reg;
+} pop;
+
+inline uint8_t get_reg(pop p) { return p._reg & ~0b10000000; }
+inline pop make_pop(reg r) {
+  pop result;
+  result._reg = r | 0b10000000;
+  return result;
+}
+
+typedef union frame_inst {
+  pop p;
+  skip s;
+  uint8_t byte;
+} frame_inst;
+
+typedef struct table_data {
+  prog_byte *data;      // r18-19
+  prog_byte *data_end;  // r20-21
+  uint16_t landing_pad; // r22-23
+  uint8_t type_index;   // r24
+  uint8_t fp_register;   // r25
+} table_data;
+
+
+table_data __fae_get_ptr(void *except, uint16_t pc);
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/config/avr/t-avr gcc-new/libgcc/config/avr/t-avr
--- gcc-13.2.0/libgcc/config/avr/t-avr	2023-07-27 01:13:07.000000000 -0700
+++ gcc-new/libgcc/config/avr/t-avr	2024-06-28 19:25:14.318313184 -0700
@@ -294,3 +294,5 @@
 LIB2FUNCS_EXCLUDE += \
 	$(foreach func,_ssmul,\
 	$(foreach mode,$(ssmul_modes),$(func_X)))
+
+LIB2ADDEH = $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/config/avr/unwind-avr.S gcc-new/libgcc/config/avr/unwind-avr.S
--- gcc-13.2.0/libgcc/config/avr/unwind-avr.S	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libgcc/config/avr/unwind-avr.S	2024-07-05 09:19:41.740619015 -0700
@@ -0,0 +1,243 @@
+.file	"unwind-avr.S"
+
+#if defined (__AVR_TINY__)
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else
+#define __zero_reg__ r1
+#define __tmp_reg__ r0
+#endif
+#define __SREG__ 0x3f
+#if defined (__AVR_HAVE_SPH__)
+#define __SP_H__ 0x3e
+#endif
+#define __SP_L__ 0x3d
+#define __RAMPZ__ 0x3B
+#define __EIND__  0x3C
+
+#if defined (__AVR_HAVE_EIJMP_EICALL__) && !defined (__AVR_HAVE_ELPMX__)
+#error device not supported
+#endif
+
+  .macro  mov_l  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+  movw  \r_dest, \r_src
+#else
+  mov \r_dest, \r_src
+#endif
+  .endm
+
+  .macro  mov_h  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+  ; empty
+#else
+  mov \r_dest, \r_src
+#endif
+  .endm
+
+.macro  wmov  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+    movw \r_dest,   \r_src
+#else
+    mov \r_dest,    \r_src
+    mov \r_dest+1,  \r_src+1
+#endif
+.endm
+
+#if defined (__AVR_HAVE_JMP_CALL__)
+#define XCALL call
+#define XJMP  jmp
+#else
+#define XCALL rcall
+#define XJMP  rjmp
+#endif
+
+#if defined (__AVR_HAVE_EIJMP_EICALL__)
+#define XICALL eicall
+#define XIJMP  eijmp
+#else
+#define XICALL icall
+#define XIJMP  ijmp
+#endif
+
+#define ZL 30
+#define ZH 31
+#define rZ 30
+
+
+#if defined (__AVR_HAVE_LPMX__)
+
+.data
+except_ptr:
+  .zero 2
+return_values:
+  .zero 8
+
+.text
+.global	_Unwind_Resume
+	.type	_Unwind_Resume, @function
+.global _Unwind_Resume_or_Rethrow ; resume_or_rethrow can be called from a forced_unwind,
+; I am not currently planning to implement forced unwinding
+	.type	_Unwind_Resume_or_Rethrow, @function
+
+.global	_Unwind_RaiseException
+	.type	_Unwind_RaiseException, @function
+
+unknown_func:
+  XCALL __avr_terminate ; std::terminate
+
+_Unwind_Resume_or_Rethrow:
+_Unwind_RaiseException:
+  sts except_ptr+1, r25
+  sts except_ptr, r24
+tailcall:
+  pop r23 ; read the return address
+  pop r22
+  lds r25, except_ptr+1
+  lds r24, except_ptr
+  XCALL __fae_get_ptr ; returns in r18-r23
+  ; r18 - data, r20 = end; r22 = landing_pad, r24 = type_index
+  cpi r18, 0 ; if no entry found
+  breq unknown_func ; std::terminate()
+  cpi r24, 0xff ; if no landing pad
+  breq no_landing_pad
+
+  cp r25, __zero_reg__ ;
+  breq goto_landing_pad ; if frame ptr is 0, do not restore bp
+  cpi r25, 28       ; base pointer is always r28 as defined in
+  brne unknown_func ; constraints.md
+  in r28, __SP_L__
+#if defined (__AVR_HAVE_SPH__)
+  in r29, __SP_H__
+#endif
+
+goto_landing_pad:
+  sts return_values,   r18
+  sts return_values+1, r19
+  sts return_values+2, r20
+  sts return_values+3, r21
+  in __tmp_reg__, __SP_H__
+  sts return_values+5, __tmp_reg__
+  in __tmp_reg__, __SP_L__
+  sts return_values+4, __tmp_reg__
+  sts return_values+6, r25
+  wmov rZ, 22 ; move landing_pad to Z
+  mov r22, r24 ; move type_index
+  lds r25, except_ptr+1
+  lds r24, except_ptr
+  XIJMP
+
+_Unwind_Resume:
+  lds r25, return_values+6
+  in __tmp_reg__, __SREG__
+  cli
+  lds r19, return_values+5
+  out __SP_H__, r19
+  lds r19, return_values+4
+  out __SREG__, __tmp_reg__
+  out __SP_L__, r19
+  lds r21, return_values+3
+  lds r20, return_values+2
+  lds r19, return_values+1
+  lds r18, return_values
+
+no_landing_pad:
+  cp r18, r20 ; if data = data_end, no unwind besides return
+  cpc r19, r21
+  breq unwind_ret
+  wmov rZ, 18
+
+unwind_loop:
+  cp r30, r20
+  cpc r31, r21
+  breq unwind_ret ; if Z == end, end loop
+  lpm r26, Z+
+  sbrc r26, 7 ; if high bit is clear, it must be a skip
+  XJMP is_pop ; else it is pop
+  cp r26, __zero_reg__ ; if skip is zero, exit loop
+  breq unwind_ret
+is_skip:
+  in r24, __SP_L__
+  in r25, __SP_H__
+  add r24, r26
+  adc r25, __zero_reg__
+  in __tmp_reg__, __SREG__
+  cli
+  out __SP_L__, r24
+  out __SREG__, __tmp_reg__
+  out __SP_H__, r25
+  XJMP unwind_loop
+unwind_ret:
+  XJMP tailcall
+; this part is actually suprisingly buggy
+; if there are weird 
+is_pop:
+  cbr r26, 0x80 ; clears high bit
+  wmov 18, rZ
+  ldi r31, 0
+  mov r30, r26
+  lsl r30 ; size of each jump is two instructions
+  ldi r27, lo8(pm(reg2))
+  add r30, r27
+  ldi r27, hi8(pm(reg2))
+  adc r31, r27
+  XIJMP
+reg2:
+  pop r2
+  rjmp end_pop
+reg3:
+  pop r3
+  rjmp end_pop
+reg4:
+  pop r4
+  rjmp end_pop
+reg5:
+  pop r5
+  rjmp end_pop
+reg6:
+  pop r6
+  rjmp end_pop
+reg7:
+  pop r7
+  rjmp end_pop
+reg8:
+  pop r8
+  rjmp end_pop
+reg9:
+  pop r9
+  rjmp end_pop
+reg10:
+  pop r10
+  rjmp end_pop
+reg11:
+  pop r11
+  rjmp end_pop
+reg12:
+  pop r12
+  rjmp end_pop
+reg13:
+  pop r13
+  rjmp end_pop
+reg14:
+  pop r14
+  rjmp end_pop
+reg15:
+  pop r15
+  rjmp end_pop
+reg16:
+  pop r16
+  rjmp end_pop
+reg17:
+  pop r17
+  rjmp end_pop
+reg28:
+  pop r28
+  rjmp end_pop
+reg29:
+  pop r29
+  rjmp end_pop
+end_pop:
+  wmov rZ, 18
+  XJMP unwind_loop
+
+#endif
\ No newline at end of file
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/config/avr/unwind-avr-sup.c gcc-new/libgcc/config/avr/unwind-avr-sup.c
--- gcc-13.2.0/libgcc/config/avr/unwind-avr-sup.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libgcc/config/avr/unwind-avr-sup.c	2024-07-06 07:30:15.224789521 -0700
@@ -0,0 +1,40 @@
+#include "fae.h"
+
+extern prog_byte __fae_table_start[];
+extern prog_byte __fae_table_stop[];
+
+typedef const table_entry_t __maybe_flash * table_ptr;
+
+void __avr_terminate() __attribute__((noreturn));
+// no plans to implement forced unwinding
+void _Unwind_ForcedUnwind() { __avr_terminate(); }
+
+// returns data pointer for pc entry. If no entry is found, return 0
+table_data __fae_get_ptr(void *except, uint16_t pc) {
+  table_data result;
+  result.type_index = 0xff;
+
+  for (table_ptr ptr = __fae_table_start; ptr < __fae_table_stop; ptr++) {
+    if (ptr->pc_begin < pc && pc <= ptr->pc_end) {
+      result.data = ptr->data;
+      result.data_end = ptr->data + ptr->length;
+      result.fp_register = ptr->frame_reg;
+      if (ptr->lsda != 0) {
+        personality_out out = {};
+        result.type_index =
+            ptr->personality(ptr->lsda, (pc - ptr->pc_begin) * 2,
+                        except, &out);
+        result.landing_pad = out.landing_pad;
+        if (result.landing_pad == 0) {
+          result.type_index = 0xff;
+          return result;
+        }
+        result.landing_pad += ptr->pc_begin * 2;
+        result.landing_pad >>= 1;
+      }
+      return result;
+    }
+  }
+  result.data = 0;
+  return result;
+}
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/unwind-dw2.c gcc-new/libgcc/unwind-dw2.c
--- gcc-13.2.0/libgcc/unwind-dw2.c	2023-07-27 01:13:07.000000000 -0700
+++ gcc-new/libgcc/unwind-dw2.c	2024-05-16 15:58:16.868929896 -0700
@@ -974,10 +974,6 @@
 		     struct _Unwind_Context *context,
 		     _Unwind_FrameState *fs)
 {
-  if (fs->data_align == __LIBGCC_DWARF_CIE_DATA_ALIGNMENT__
-      && fs->code_align == 1)
-    execute_cfa_program_specialized (insn_ptr, insn_end, context, fs);
-  else
     execute_cfa_program_generic (insn_ptr, insn_end, context, fs);
 }
 
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/unwind-generic.h gcc-new/libgcc/unwind-generic.h
--- gcc-13.2.0/libgcc/unwind-generic.h	2023-07-27 01:13:07.000000000 -0700
+++ gcc-new/libgcc/unwind-generic.h	2024-05-23 20:03:38.624398808 -0700
@@ -130,7 +130,7 @@
 
 /* Raise an exception, passing along the given exception object.  */
 extern _Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
-_Unwind_RaiseException (struct _Unwind_Exception *);
+_Unwind_RaiseException (struct _Unwind_Exception *) __attribute__((weak));
 
 /* Raise an exception for forced unwinding.  */
 
@@ -138,16 +138,22 @@
      (int, _Unwind_Action, _Unwind_Exception_Class,
       struct _Unwind_Exception *, struct _Unwind_Context *, void *);
 
-extern _Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
+ __attribute__((weak)) extern _Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
 _Unwind_ForcedUnwind (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);
 
 /* Helper to invoke the exception_cleanup routine.  */
-extern void _Unwind_DeleteException (struct _Unwind_Exception *);
+inline void
+_Unwind_DeleteException (struct _Unwind_Exception *exc)
+{
+  if (exc->exception_cleanup)
+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
+}
+
 
 /* Resume propagation of an existing exception.  This is used after
    e.g. executing cleanup code, and not to implement rethrowing.  */
 extern void LIBGCC2_UNWIND_ATTRIBUTE
-_Unwind_Resume (struct _Unwind_Exception *);
+_Unwind_Resume (struct _Unwind_Exception *)  __attribute__((weak));
 
 /* @@@ Resume propagation of a FORCE_UNWIND exception, or to rethrow
    a normal exception that was handled.  */
@@ -247,6 +253,10 @@
    contains it.  */
 extern void * _Unwind_FindEnclosingFunction (void *pc);
 
+#ifndef __SIZEOF_INT__
+  #error "__SIZEOF_INT__ macro not defined"
+#endif
+
 #ifndef __SIZEOF_LONG__
   #error "__SIZEOF_LONG__ macro not defined"
 #endif
@@ -256,6 +266,7 @@
 #endif
 
 
+
 /* leb128 type numbers have a potentially unlimited size.
    The target of the following definitions of _sleb128_t and _uleb128_t
    is to have efficient data types large enough to hold the leb128 type
@@ -264,7 +275,10 @@
    except when a unsigned long data type on the target machine is not
    capable of storing a pointer.  */
 
-#if __SIZEOF_LONG__ >= __SIZEOF_POINTER__
+#if __SIZEOF_INT__ >= __SIZEOF_POINTER__
+  typedef int _sleb128_t;
+  typedef unsigned int _uleb128_t;
+#elif __SIZEOF_LONG__ >= __SIZEOF_POINTER__
   typedef long _sleb128_t;
   typedef unsigned long _uleb128_t;
 #elif __SIZEOF_LONG_LONG__ >= __SIZEOF_POINTER__
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/unwind.inc gcc-new/libgcc/unwind.inc
--- gcc-13.2.0/libgcc/unwind.inc	2023-07-27 01:13:07.000000000 -0700
+++ gcc-new/libgcc/unwind.inc	2024-05-31 10:58:48.127709146 -0700
@@ -82,8 +82,8 @@
 
 /* Raise an exception, passing along the given exception object.  */
 
-_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
-_Unwind_RaiseException(struct _Unwind_Exception *exc)
+_Unwind_Reason_Code  LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
+_Unwind_RaiseException(struct _Unwind_Exception *exc) 
 {
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
@@ -201,7 +201,7 @@
 
 /* Raise an exception for forced unwinding.  */
 
-_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
+_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
 _Unwind_ForcedUnwind (struct _Unwind_Exception *exc,
 		      _Unwind_Stop_Fn stop, void * stop_argument)
 {
@@ -226,7 +226,7 @@
 /* Resume propagation of an existing exception.  This is used after
    e.g. executing cleanup code, and not to implement rethrowing.  */
 
-void LIBGCC2_UNWIND_ATTRIBUTE
+void LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
 _Unwind_Resume (struct _Unwind_Exception *exc)
 {
   struct _Unwind_Context this_context, cur_context;
@@ -252,7 +252,7 @@
 /* Resume propagation of an FORCE_UNWIND exception, or to rethrow
    a normal exception that was handled.  */
 
-_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
+_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
 _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)
 {
   struct _Unwind_Context this_context, cur_context;
@@ -275,16 +275,6 @@
 }
 
 
-/* A convenience function that calls the exception_cleanup field.  */
-
-void
-_Unwind_DeleteException (struct _Unwind_Exception *exc)
-{
-  if (exc->exception_cleanup)
-    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
-}
-
-
 /* Perform stack backtrace through unwind data.  */
 
 _Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libgcc/unwind-seh.c gcc-new/libgcc/unwind-seh.c
--- gcc-13.2.0/libgcc/unwind-seh.c	2023-07-27 01:13:07.000000000 -0700
+++ gcc-new/libgcc/unwind-seh.c	2024-05-23 20:04:29.304384262 -0700
@@ -419,14 +419,6 @@
   return _Unwind_ForcedUnwind_Phase2 (exc);
 }
 
-/* A convenience function that calls the exception_cleanup field.  */
-
-void
-_Unwind_DeleteException (struct _Unwind_Exception *exc)
-{
-  if (exc->exception_cleanup)
-    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
-}
 
 /* Perform stack backtrace through unwind data.  */
 
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h gcc-new/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h	2024-05-25 14:00:44.077691243 -0700
@@ -0,0 +1,44 @@
+// Low-level functions for atomic operations: version for CPUs providing
+// atomic builtins -*- C++ -*-
+
+// Copyright (C) 2006-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <bits/c++config.h>
+#include <bits/atomic_word.h>
+
+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h gcc-new/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h	2024-05-25 14:00:44.077691243 -0700
@@ -0,0 +1,59 @@
+// Low-level functions for atomic operations: Generic version  -*- C++ -*-
+
+// Copyright (C) 1999-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <ext/atomicity.h>
+#include <ext/concurrence.h>
+
+namespace
+{
+  __gnu_cxx::__mutex&
+  get_atomic_mutex()
+  {
+    static __gnu_cxx::__mutex atomic_mutex;
+    return atomic_mutex;
+  }
+} // anonymous namespace
+
+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add(volatile _Atomic_word* __mem, int __val) throw ()
+  {
+    __gnu_cxx::__scoped_lock sentry(get_atomic_mutex());
+    _Atomic_word __result;
+    __result = *__mem;
+    *__mem += __val;
+    return __result;
+  }
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { __exchange_and_add(__mem, __val); }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomic_word.h gcc-new/libstdc++-v3/config/cpu/avr/atomic_word.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/atomic_word.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/atomic_word.h	2024-05-25 14:00:44.067691244 -0700
@@ -0,0 +1,40 @@
+// Low-level type for atomic operations -*- C++ -*-
+
+// Copyright (C) 2004-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file atomic_word.h
+ *  This file is a GNU extension to the Standard C++ Library.
+ */
+
+#ifndef _GLIBCXX_ATOMIC_WORD_H
+#define _GLIBCXX_ATOMIC_WORD_H	1
+
+typedef int _Atomic_word;
+
+
+// This is a memory order acquire fence.
+#define _GLIBCXX_READ_MEM_BARRIER __atomic_thread_fence (__ATOMIC_ACQUIRE)
+// This is a memory order release fence.
+#define _GLIBCXX_WRITE_MEM_BARRIER __atomic_thread_fence (__ATOMIC_RELEASE)
+
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/cpu_defines.h gcc-new/libstdc++-v3/config/cpu/avr/cpu_defines.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/cpu_defines.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/cpu_defines.h	2024-05-25 14:00:44.067691244 -0700
@@ -0,0 +1,33 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2005-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/cpu_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_CPU_DEFINES
+#define _GLIBCXX_CPU_DEFINES 1
+
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h gcc-new/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h	2024-05-25 14:00:44.067691244 -0700
@@ -0,0 +1,59 @@
+// Control various target specific ABI tweaks.  Generic version.
+
+// Copyright (C) 2004-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/cxxabi_tweaks.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{cxxabi.h}
+ */
+
+#ifndef _CXXABI_TWEAKS_H
+#define _CXXABI_TWEAKS_H 1
+
+#ifdef __cplusplus
+namespace __cxxabiv1
+{
+  extern "C"
+  {
+#endif
+
+  // The generic ABI uses the first byte of a 64-bit guard variable.
+#define _GLIBCXX_GUARD_TEST(x) (*(char *) (x) != 0)
+#define _GLIBCXX_GUARD_SET(x) *(char *) (x) = 1
+#define _GLIBCXX_GUARD_BIT __guard_test_bit (0, 1)
+#define _GLIBCXX_GUARD_PENDING_BIT __guard_test_bit (1, 1)
+#define _GLIBCXX_GUARD_WAITING_BIT __guard_test_bit (2, 1)
+  __extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+  // __cxa_vec_ctor has void return type.
+  typedef void __cxa_vec_ctor_return_type;
+#define _GLIBCXX_CXA_VEC_CTOR_RETURN(x) return
+  // Constructors and destructors do not return a value.
+  typedef void __cxa_cdtor_return_type;
+
+#ifdef __cplusplus
+  }
+} // namespace __cxxabiv1
+#endif
+
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h gcc-new/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h	2024-05-25 14:00:44.077691243 -0700
@@ -0,0 +1,38 @@
+// Optimizations for random number handling, generic version -*- C++ -*-
+
+// Copyright (C) 2012-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/opt_random.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{random}
+ */
+
+#ifndef _BITS_OPT_RANDOM_H
+#define _BITS_OPT_RANDOM_H 1
+
+#pragma GCC system_header
+
+
+
+
+#endif // _BITS_OPT_RANDOM_H
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h gcc-new/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h
--- gcc-13.2.0/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h	2024-05-25 14:00:44.077691243 -0700
@@ -0,0 +1,38 @@
+// Optimizations for random number extensions, generic version -*- C++ -*-
+
+// Copyright (C) 2012-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ext/opt_random.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{ext/random}
+ */
+
+#ifndef _EXT_OPT_RANDOM_H
+#define _EXT_OPT_RANDOM_H 1
+
+#pragma GCC system_header
+
+
+
+
+#endif // _EXT_OPT_RANDOM_H
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_base.h gcc-new/libstdc++-v3/config/os/avrlibc/ctype_base.h
--- gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_base.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/os/avrlibc/ctype_base.h	2024-05-25 11:27:05.784778219 -0700
@@ -0,0 +1,59 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// Default information, may not be appropriate for specific host.
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned int 	mask;
+    static const mask upper    	= 1 << 0;
+    static const mask lower 	= 1 << 1;
+    static const mask alpha 	= 1 << 2;
+    static const mask digit 	= 1 << 3;
+    static const mask xdigit 	= 1 << 4;
+    static const mask space 	= 1 << 5;
+    static const mask print 	= 1 << 6;
+    static const mask graph 	= (1 << 2) | (1 << 3) | (1 << 9); // alnum|punct
+    static const mask cntrl 	= 1 << 8;
+    static const mask punct 	= 1 << 9;
+    static const mask alnum 	= (1 << 2) | (1 << 3);  // alpha|digit
+    static const mask blank	= 1 << 10;
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc gcc-new/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc
--- gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc	2024-05-25 11:27:05.784778219 -0700
@@ -0,0 +1,99 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+// Information as gleaned from /usr/include/ctype.h
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  { return 0; }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
+		     size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return ::toupper((int) __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::toupper((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return ::tolower((int) __c); }
+
+  const char*
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::tolower((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_inline.h gcc-new/libstdc++-v3/config/os/avrlibc/ctype_inline.h
--- gcc-13.2.0/libstdc++-v3/config/os/avrlibc/ctype_inline.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/os/avrlibc/ctype_inline.h	2024-05-25 11:27:05.784778219 -0700
@@ -0,0 +1,173 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+
+// The following definitions are portable, but insanely slow. If one
+// cares at all about performance, then specialized ctype
+// functionality should be added for the native os in question: see
+// the config/os/bits/ctype_*.h files.
+
+// Constructing a synthetic "C" table should be seriously considered...
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  {
+    if (_M_table)
+      return _M_table[static_cast<unsigned char>(__c)] & __m;
+    else
+      {
+	bool __ret = false;
+	const size_t __bitmasksize = 15;
+	size_t __bitcur = 0; // Lowest bitmask in ctype_base == 0
+	for (; __bitcur <= __bitmasksize; ++__bitcur)
+	  {
+	    const mask __bit = static_cast<mask>(1 << __bitcur);
+	    if (__m & __bit)
+	      {
+		bool __testis;
+		switch (__bit)
+		  {
+		  case space:
+		    __testis = isspace(__c);
+		    break;
+		  case print:
+		    __testis = isprint(__c);
+		    break;
+		  case cntrl:
+		    __testis = iscntrl(__c);
+		    break;
+		  case upper:
+		    __testis = isupper(__c);
+		    break;
+		  case lower:
+		    __testis = islower(__c);
+		    break;
+		  case alpha:
+		    __testis = isalpha(__c);
+		    break;
+		  case digit:
+		    __testis = isdigit(__c);
+		    break;
+		  case punct:
+		    __testis = ispunct(__c);
+		    break;
+		  case xdigit:
+		    __testis = isxdigit(__c);
+		    break;
+		  case alnum:
+		    __testis = isalnum(__c);
+		    break;
+		  case graph:
+		    __testis = isgraph(__c);
+		    break;
+#ifdef _GLIBCXX_USE_C99_CTYPE_TR1
+		  case blank:
+		    __testis = isblank(__c);
+		    break;
+#endif
+		  default:
+		    __testis = false;
+		    break;
+		  }
+		__ret |= __testis;
+	      }
+	  }
+	return __ret;
+      }
+  }
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    if (_M_table)
+      while (__low < __high)
+	*__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
+    else
+      {
+	// Highest bitmask in ctype_base == 11.
+	const size_t __bitmasksize = 15;
+	for (;__low < __high; ++__vec, ++__low)
+	  {
+	    mask __m = 0;
+	    // Lowest bitmask in ctype_base == 0
+	    size_t __i = 0;
+	    for (;__i <= __bitmasksize; ++__i)
+	      {
+		const mask __bit = static_cast<mask>(1 << __i);
+		if (this->is(__bit, *__low))
+		  __m |= __bit;
+	      }
+	    *__vec = __m;
+	  }
+      }
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    if (_M_table)
+      while (__low < __high
+	     && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
+	++__low;
+    else
+      while (__low < __high && !this->is(__m, *__low))
+	++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    if (_M_table)
+      while (__low < __high
+	     && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
+	++__low;
+    else
+      while (__low < __high && this->is(__m, *__low) != 0)
+	++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/avrlibc/error_constants.h gcc-new/libstdc++-v3/config/os/avrlibc/error_constants.h
--- gcc-13.2.0/libstdc++-v3/config/os/avrlibc/error_constants.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/os/avrlibc/error_constants.h	2024-05-25 11:27:05.784778219 -0700
@@ -0,0 +1,180 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2007-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/error_constants.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{system_error}
+ */
+
+#ifndef _GLIBCXX_ERROR_CONSTANTS
+#define _GLIBCXX_ERROR_CONSTANTS 1
+
+#include <bits/c++config.h>
+#include <cerrno>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  enum class errc
+    {
+      address_family_not_supported = 		EAFNOSUPPORT,
+      address_in_use = 				EADDRINUSE,
+      address_not_available = 			EADDRNOTAVAIL,
+      already_connected = 			EISCONN,
+      argument_list_too_long = 			E2BIG,
+      argument_out_of_domain = 			EDOM,
+      bad_address = 				EFAULT,
+      bad_file_descriptor = 			EBADF,
+
+#ifdef EBADMSG
+      bad_message = 				EBADMSG,
+#endif
+
+      broken_pipe = 				EPIPE,
+      connection_aborted = 			ECONNABORTED,
+      connection_already_in_progress = 		EALREADY,
+      connection_refused = 			ECONNREFUSED,
+      connection_reset = 			ECONNRESET,
+      cross_device_link = 			EXDEV,
+      destination_address_required = 		EDESTADDRREQ,
+      device_or_resource_busy = 		EBUSY,
+      directory_not_empty = 			ENOTEMPTY,
+      executable_format_error = 		ENOEXEC,
+      file_exists = 	       			EEXIST,
+      file_too_large = 				EFBIG,
+      filename_too_long = 			ENAMETOOLONG,
+      function_not_supported = 			ENOSYS,
+      host_unreachable = 			EHOSTUNREACH,
+
+#ifdef EIDRM
+      identifier_removed = 			EIDRM,
+#endif
+
+      illegal_byte_sequence = 			EILSEQ,
+      inappropriate_io_control_operation = 	ENOTTY,
+      interrupted = 				EINTR,
+      invalid_argument = 			EINVAL,
+      invalid_seek = 				ESPIPE,
+      io_error = 				EIO,
+      is_a_directory = 				EISDIR,
+      message_size = 				EMSGSIZE,
+      network_down = 				ENETDOWN,
+      network_reset = 				ENETRESET,
+      network_unreachable = 			ENETUNREACH,
+      no_buffer_space = 			ENOBUFS,
+      no_child_process = 			ECHILD,
+
+#ifdef ENOLINK
+      no_link = 				ENOLINK,
+#endif
+
+      no_lock_available = 			ENOLCK,
+
+#ifdef ENODATA
+      no_message_available = 			ENODATA,
+#endif
+
+      no_message = 				ENOMSG,
+      no_protocol_option = 			ENOPROTOOPT,
+      no_space_on_device = 			ENOSPC,
+
+#ifdef ENOSR
+      no_stream_resources = 			ENOSR,
+#endif
+
+      no_such_device_or_address = 		ENXIO,
+      no_such_device = 				ENODEV,
+      no_such_file_or_directory = 		ENOENT,
+      no_such_process = 			ESRCH,
+      not_a_directory = 			ENOTDIR,
+      not_a_socket = 				ENOTSOCK,
+
+#ifdef ENOSTR
+      not_a_stream = 				ENOSTR,
+#endif
+
+      not_connected = 				ENOTCONN,
+      not_enough_memory = 			ENOMEM,
+
+#ifdef ENOTSUP
+      not_supported = 				ENOTSUP,
+#endif
+
+#ifdef ECANCELED
+      operation_canceled = 			ECANCELED,
+#endif
+
+      operation_in_progress = 			EINPROGRESS,
+      operation_not_permitted = 		EPERM,
+      operation_not_supported = 		EOPNOTSUPP,
+      operation_would_block = 			EWOULDBLOCK,
+
+#ifdef EOWNERDEAD
+      owner_dead = 				EOWNERDEAD,
+#endif
+
+      permission_denied = 			EACCES,
+
+#ifdef EPROTO
+      protocol_error = 				EPROTO,
+#endif
+
+      protocol_not_supported = 			EPROTONOSUPPORT,
+      read_only_file_system = 			EROFS,
+      resource_deadlock_would_occur = 		EDEADLK,
+      resource_unavailable_try_again = 		EAGAIN,
+      result_out_of_range = 			ERANGE,
+
+#ifdef ENOTRECOVERABLE
+      state_not_recoverable = 			ENOTRECOVERABLE,
+#endif
+
+#ifdef ETIME
+      stream_timeout = 				ETIME,
+#endif
+
+#ifdef ETXTBSY
+      text_file_busy = 				ETXTBSY,
+#endif
+
+      timed_out = 				ETIMEDOUT,
+      too_many_files_open_in_system = 		ENFILE,
+      too_many_files_open = 			EMFILE,
+      too_many_links = 				EMLINK,
+      too_many_symbolic_link_levels = 		ELOOP,
+
+#ifdef EOVERFLOW
+      value_too_large = 			EOVERFLOW,
+#elif defined __AVR__
+      value_too_large = 			999,
+#endif
+
+      wrong_protocol_type = 			EPROTOTYPE
+    };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
+
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/avrlibc/os_defines.h gcc-new/libstdc++-v3/config/os/avrlibc/os_defines.h
--- gcc-13.2.0/libstdc++-v3/config/os/avrlibc/os_defines.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/config/os/avrlibc/os_defines.h	2024-05-25 11:27:05.784778219 -0700
@@ -0,0 +1,41 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+// Disable the weak reference logic in gthr.h for os/generic because it
+// is broken on every platform unless there is implementation specific
+// workaround in gthr-posix.h and at link-time for static linking.
+#define _GLIBCXX_GTHREAD_USE_WEAK 0
+
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/config/os/newlib/ctype_configure_char.cc gcc-new/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
--- gcc-13.2.0/libstdc++-v3/config/os/newlib/ctype_configure_char.cc	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/config/os/newlib/ctype_configure_char.cc	2024-05-25 11:21:25.844753989 -0700
@@ -40,7 +40,7 @@
 
   const ctype_base::mask*
   ctype<char>::classic_table() throw()
-  { return _ctype_ + 1; }
+  { return 0; }
 
   ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
 		     size_t __refs)
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/crossconfig.m4 gcc-new/libstdc++-v3/crossconfig.m4
--- gcc-13.2.0/libstdc++-v3/crossconfig.m4	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/crossconfig.m4	2024-05-25 11:23:13.494759022 -0700
@@ -33,6 +33,29 @@
     AC_DEFINE(HAVE_SINHF)
     AC_DEFINE(HAVE_TANF)
     AC_DEFINE(HAVE_TANHF)
+    AC_DEFINE(HAVE_ACOSL)
+    AC_DEFINE(HAVE_ASINL)
+    AC_DEFINE(HAVE_ATAN2L)
+    AC_DEFINE(HAVE_ATANL)
+    AC_DEFINE(HAVE_CEILL)
+    AC_DEFINE(HAVE_COSL)
+    AC_DEFINE(HAVE_COSHL)
+    AC_DEFINE(HAVE_EXPL)
+    AC_DEFINE(HAVE_FABSL)
+    AC_DEFINE(HAVE_FLOORL)
+    AC_DEFINE(HAVE_FMODL)
+    AC_DEFINE(HAVE_FREXPL)
+    AC_DEFINE(HAVE_LDEXPL)
+    AC_DEFINE(HAVE_LOG10L)
+    AC_DEFINE(HAVE_LOGL)
+    AC_DEFINE(HAVE_MODFL)
+    AC_DEFINE(HAVE_POWL)
+    AC_DEFINE(HAVE_SINCOSL)
+    AC_DEFINE(HAVE_SINL)
+    AC_DEFINE(HAVE_SINHL)
+    AC_DEFINE(HAVE_SQRTL)
+    AC_DEFINE(HAVE_TANL)
+    AC_DEFINE(HAVE_TANHL)
     ;;
 
   mips*-sde-elf*)
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/include/c_global/cmath gcc-new/libstdc++-v3/include/c_global/cmath
--- gcc-13.2.0/libstdc++-v3/include/c_global/cmath	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/include/c_global/cmath	2024-07-05 12:47:25.081293553 -0700
@@ -83,6 +83,7 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   using ::acos;
+  using ::isinf;
 
 #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
   inline _GLIBCXX_CONSTEXPR float
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/libsupc++/eh_avr.cc gcc-new/libstdc++-v3/libsupc++/eh_avr.cc
--- gcc-13.2.0/libstdc++-v3/libsupc++/eh_avr.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-new/libstdc++-v3/libsupc++/eh_avr.cc	2024-07-06 08:48:04.814443897 -0700
@@ -0,0 +1,169 @@
+#ifdef __AVR_ARCH__
+
+
+
+#include <bits/c++config.h>
+#include <bits/exception_defines.h>
+#include <cxxabi.h>
+#include "unwind-cxx.h"
+#include <cstdlib>
+
+#include <typeinfo>
+#include "unwind-pe.h"
+#include <avr/pgmspace.h>
+
+typedef unsigned char uint8_t;
+typedef unsigned int uint16_t;
+typedef int int16_t;
+
+namespace __cxxabiv1{
+static void *get_adjusted_ptr(const void *c, const std::type_info *t,
+                              void *thrown_ptr) noexcept {
+  auto catch_type = static_cast<const std::type_info *>(c);
+  auto throw_type = static_cast<const std::type_info *>(t);
+  if (throw_type->__is_pointer_p())
+    thrown_ptr = *(void **)thrown_ptr;
+
+  if (catch_type->__do_catch(throw_type, &thrown_ptr, 1)) {
+    return thrown_ptr;
+  }
+
+  return nullptr;
+}
+
+static void *get_adjusted_ptr(void *exc,
+                                        const void *catch_type) noexcept {
+  auto ue = static_cast<_Unwind_Exception *>(exc);
+  auto cxa_except = __get_exception_header_from_ue(ue);
+  auto thrown_obj = __get_object_from_ue(ue);
+  auto thrown_type = cxa_except->exceptionType;
+  cxa_except->adjustedPtr =
+      get_adjusted_ptr(catch_type, thrown_type, thrown_obj);
+  return cxa_except->adjustedPtr;
+}
+
+extern "C" void __avr_terminate() {
+  std::terminate();
+}
+
+typedef const uint8_t prog_byte;
+typedef void* void_ptr;
+typedef const void_ptr *prog_ptr;
+
+
+static uint8_t get(prog_byte* p){
+  return __LPM((unsigned)p);
+}
+
+static void* getw(prog_ptr p){
+  return (void*) __LPM_word((unsigned)p);
+}
+
+static uint8_t uleb(prog_byte *ptr, uint16_t *out) {
+  *out = get(ptr++);
+  if (!(*out & 0b10000000)) {
+    return 1;
+  } else {
+    *out &= 0b01111111;
+    if (get(ptr) & 0b00000001) {
+      *out |= 0b10000000;
+    }
+    *out |= get(ptr) << 7;
+    return 2;
+  }
+}
+
+
+static uint8_t sleb(prog_byte *ptr, int16_t *const val) {
+  int16_t i = 0;
+
+  uint8_t b = get(&ptr[i++]);
+  *val = b & 0b01111111;
+
+  if (b & 0b10000000) {
+    b = get(&ptr[i++]);
+    *val <<= 7;
+    *val |= b & 0b01111111;
+  }
+
+  if (b & 0x40) {
+    *val |= (-1ULL) << 7;
+    return i;
+  }
+  return i;
+}
+
+struct personality_out{
+  uint16_t landing_pad;
+};
+
+
+// this is very bad, and probably should be rewritten in assembly for speed/size
+extern "C" uint8_t __avr_cxx_personality(prog_byte *ptr, uint16_t pc_offset, void *exc,
+                           personality_out *out) noexcept {
+  uint8_t lp_encoding = get(ptr++);
+  uint16_t lp_offset = 0;
+  if (lp_encoding != DW_EH_PE_omit) {
+    // in reality lp offset never seems to be set. This should really
+    // consider if lp offset is set or not, but for now it works
+    ptr += uleb(ptr, &lp_offset);
+  }
+  uint8_t type_encoding = get(ptr++);
+  uint16_t types_offset = 0;
+  if (type_encoding != DW_EH_PE_omit) {
+    ptr += uleb(ptr, &types_offset);
+  }
+
+  prog_ptr type_table = reinterpret_cast<prog_ptr>(ptr + types_offset);
+  uint8_t call_encoding = get(ptr++);
+  uint16_t call_table_length;
+  ptr += uleb(ptr, &call_table_length);
+  if ((type_encoding != DW_EH_PE_absptr && type_encoding != DW_EH_PE_omit) ||
+      call_encoding != DW_EH_PE_uleb128) {
+    __avr_terminate();
+  }
+  prog_byte *end = ptr + call_table_length;
+  uint16_t lp_ip;
+  uint16_t action_offset;
+  while (ptr < end) {
+    uint16_t ip_start;
+    ptr += uleb(ptr, &ip_start);
+    uint16_t ip_range;
+    ptr += uleb(ptr, &ip_range);
+    ptr += uleb(ptr, &lp_ip);
+    ptr += uleb(ptr, &action_offset);
+    if (ip_start < pc_offset && pc_offset <= ip_start + ip_range) {
+      out->landing_pad = lp_ip;
+      goto found_handler;
+    }
+  }
+  __avr_terminate();
+found_handler:
+  if (action_offset == 0) {
+    return 0;
+  }
+  ptr = end + action_offset - 1;
+  while (1) {
+    int16_t action, offset;
+    ptr += sleb(ptr, &action);
+    sleb(ptr, &offset);
+    ptr += offset;
+    if (action != 0) {
+      void *catch_type = getw(&type_table[-1 * action]);
+      if (catch_type == 0) // if it is a catch(...) block, match anything
+        return action;
+      void *ptr = get_adjusted_ptr(exc, catch_type);
+      if (ptr) {
+        return action;
+      }
+    } else {
+      return 0;
+    }
+    if (offset == 0)
+      break;
+  }
+  __avr_terminate();
+}
+
+}
+#endif
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/libsupc++/eh_personality.cc gcc-new/libstdc++-v3/libsupc++/eh_personality.cc
--- gcc-13.2.0/libstdc++-v3/libsupc++/eh_personality.cc	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/libsupc++/eh_personality.cc	2024-07-03 07:23:08.107411866 -0700
@@ -333,406 +333,6 @@
 namespace __cxxabiv1
 {
 
-// Using a different personality function name causes link failures
-// when trying to mix code using different exception handling models.
-#ifdef __USING_SJLJ_EXCEPTIONS__
-#define PERSONALITY_FUNCTION	__gxx_personality_sj0
-#define __builtin_eh_return_data_regno(x) x
-#elif defined(__SEH__)
-#define PERSONALITY_FUNCTION	__gxx_personality_imp
-#else
-#define PERSONALITY_FUNCTION	__gxx_personality_v0
-#endif
-
-#if defined (__SEH__) && !defined (__USING_SJLJ_EXCEPTIONS__)
-static
-#else
-extern "C"
-#endif
-_Unwind_Reason_Code
-#ifdef __ARM_EABI_UNWINDER__
-__attribute__((target ("general-regs-only")))
-PERSONALITY_FUNCTION (_Unwind_State state,
-		      struct _Unwind_Exception* ue_header,
-		      struct _Unwind_Context* context)
-#else
-PERSONALITY_FUNCTION (int version,
-		      _Unwind_Action actions,
-		      _Unwind_Exception_Class exception_class,
-		      struct _Unwind_Exception *ue_header,
-		      struct _Unwind_Context *context)
-#endif
-{
-  enum found_handler_type
-  {
-    found_nothing,
-    found_terminate,
-    found_cleanup,
-    found_handler
-  } found_type;
-
-  lsda_header_info info;
-  const unsigned char *language_specific_data;
-  const unsigned char *action_record;
-  const unsigned char *p;
-  _Unwind_Ptr landing_pad, ip;
-  int handler_switch_value;
-  void* thrown_ptr = 0;
-  bool foreign_exception;
-  int ip_before_insn = 0;
-
-#ifdef __ARM_EABI_UNWINDER__
-  _Unwind_Action actions;
-
-  switch (state & _US_ACTION_MASK)
-    {
-    case _US_VIRTUAL_UNWIND_FRAME:
-      // If the unwind state pattern is
-      // _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
-      // then we don't need to search for any handler as it is not a real
-      // exception. Just unwind the stack.
-      if (state & _US_FORCE_UNWIND)
-	CONTINUE_UNWINDING;
-      actions = _UA_SEARCH_PHASE;
-      break;
-
-    case _US_UNWIND_FRAME_STARTING:
-      actions = _UA_CLEANUP_PHASE;
-      if (!(state & _US_FORCE_UNWIND)
-	  && ue_header->barrier_cache.sp == _Unwind_GetGR(context,
-							  UNWIND_STACK_REG))
-	actions |= _UA_HANDLER_FRAME;
-      break;
-
-    case _US_UNWIND_FRAME_RESUME:
-      CONTINUE_UNWINDING;
-      break;
-
-    default:
-      std::abort();
-    }
-  actions |= state & _US_FORCE_UNWIND;
-
-  // We don't know which runtime we're working with, so can't check this.
-  // However the ABI routines hide this from us, and we don't actually need
-  // to know.
-  foreign_exception = false;
-
-  // The dwarf unwinder assumes the context structure holds things like the
-  // function and LSDA pointers.  The ARM implementation caches these in
-  // the exception header (UCB).  To avoid rewriting everything we make a
-  // virtual scratch register point at the UCB.
-  ip = (_Unwind_Ptr) ue_header;
-  _Unwind_SetGR(context, UNWIND_POINTER_REG, ip);
-#else
-  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);
-
-  // Interface version check.
-  if (version != 1)
-    return _URC_FATAL_PHASE1_ERROR;
-  foreign_exception = !__is_gxx_exception_class(exception_class);
-#endif
-
-  // Shortcut for phase 2 found handler for domestic exception.
-  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)
-      && !foreign_exception)
-    {
-      restore_caught_exception(ue_header, handler_switch_value,
-			       language_specific_data, landing_pad);
-      found_type = (landing_pad == 0 ? found_terminate : found_handler);
-      goto install_context;
-    }
-
-  language_specific_data = (const unsigned char *)
-    _Unwind_GetLanguageSpecificData (context);
-
-  // If no LSDA, then there are no handlers or cleanups.
-  if (! language_specific_data)
-    CONTINUE_UNWINDING;
-
-  // Parse the LSDA header.
-  p = parse_lsda_header (context, language_specific_data, &info);
-  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);
-#ifdef _GLIBCXX_HAVE_GETIPINFO
-  ip = _Unwind_GetIPInfo (context, &ip_before_insn);
-#else
-  ip = _Unwind_GetIP (context);
-#endif
-  if (! ip_before_insn)
-    --ip;
-  landing_pad = 0;
-  action_record = 0;
-  handler_switch_value = 0;
-
-#ifdef __USING_SJLJ_EXCEPTIONS__
-  // The given "IP" is an index into the call-site table, with two
-  // exceptions -- -1 means no-action, and 0 means terminate.  But
-  // since we're using uleb128 values, we've not got random access
-  // to the array.
-  if ((int) ip < 0)
-    return _URC_CONTINUE_UNWIND;
-  else if (ip == 0)
-    {
-      // Fall through to set found_terminate.
-    }
-  else
-    {
-      _uleb128_t cs_lp, cs_action;
-      do
-	{
-	  p = read_uleb128 (p, &cs_lp);
-	  p = read_uleb128 (p, &cs_action);
-	}
-      while (--ip);
-
-      // Can never have null landing pad for sjlj -- that would have
-      // been indicated by a -1 call site index.
-      landing_pad = cs_lp + 1;
-      if (cs_action)
-	action_record = info.action_table + cs_action - 1;
-      goto found_something;
-    }
-#else
-  // Search the call-site table for the action associated with this IP.
-  while (p < info.action_table)
-    {
-      _Unwind_Ptr cs_start, cs_len, cs_lp;
-      _uleb128_t cs_action;
-
-      // Note that all call-site encodings are "absolute" displacements.
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);
-      p = read_uleb128 (p, &cs_action);
-
-      // The table is sorted, so if we've passed the ip, stop.
-      if (ip < info.Start + cs_start)
-	p = info.action_table;
-      else if (ip < info.Start + cs_start + cs_len)
-	{
-	  if (cs_lp)
-	    landing_pad = info.LPStart + cs_lp;
-	  if (cs_action)
-	    action_record = info.action_table + cs_action - 1;
-	  goto found_something;
-	}
-    }
-#endif // __USING_SJLJ_EXCEPTIONS__
-
-  // If ip is not present in the table, call terminate.  This is for
-  // a destructor inside a cleanup, or a library routine the compiler
-  // was not expecting to throw.
-  found_type = found_terminate;
-  goto do_something;
-
- found_something:
-  if (landing_pad == 0)
-    {
-      // If ip is present, and has a null landing pad, there are
-      // no cleanups or handlers to be run.
-      found_type = found_nothing;
-    }
-  else if (action_record == 0)
-    {
-      // If ip is present, has a non-null landing pad, and a null
-      // action table offset, then there are only cleanups present.
-      // Cleanups use a zero switch value, as set above.
-      found_type = found_cleanup;
-    }
-  else
-    {
-      // Otherwise we have a catch handler or exception specification.
-
-      _sleb128_t ar_filter, ar_disp;
-      const std::type_info* catch_type;
-      _throw_typet* throw_type;
-      bool saw_cleanup = false;
-      bool saw_handler = false;
-
-#ifdef __ARM_EABI_UNWINDER__
-      // ??? How does this work - more importantly, how does it interact with
-      // dependent exceptions?
-      throw_type = ue_header;
-      if (actions & _UA_FORCE_UNWIND)
-	{
-	  __GXX_INIT_FORCED_UNWIND_CLASS(ue_header->exception_class);
-	}
-      else if (!foreign_exception)
-	thrown_ptr = __get_object_from_ue (ue_header);
-#else
-#if __cpp_rtti
-      // During forced unwinding, match a magic exception type.
-      if (actions & _UA_FORCE_UNWIND)
-	{
-	  throw_type = &typeid(abi::__forced_unwind);
-	}
-      // With a foreign exception class, there's no exception type.
-      // ??? What to do about GNU Java and GNU Ada exceptions?
-      else if (foreign_exception)
-	{
-	  throw_type = &typeid(abi::__foreign_exception);
-	}
-      else
-#endif
-        {
-          thrown_ptr = __get_object_from_ue (ue_header);
-          throw_type = __get_exception_header_from_obj
-            (thrown_ptr)->exceptionType;
-        }
-#endif
-
-      while (1)
-	{
-	  p = action_record;
-	  p = read_sleb128 (p, &ar_filter);
-	  read_sleb128 (p, &ar_disp);
-
-	  if (ar_filter == 0)
-	    {
-	      // Zero filter values are cleanups.
-	      saw_cleanup = true;
-	    }
-	  else if (ar_filter > 0)
-	    {
-	      // Positive filter values are handlers.
-	      catch_type = get_ttype_entry (&info, ar_filter);
-
-	      // Null catch type is a catch-all handler; we can catch foreign
-	      // exceptions with this.  Otherwise we must match types.
-	      if (! catch_type
-		  || (throw_type
-		      && get_adjusted_ptr (catch_type, throw_type,
-					   &thrown_ptr)))
-		{
-		  saw_handler = true;
-		  break;
-		}
-	    }
-	  else
-	    {
-	      // Negative filter values are exception specifications.
-	      // ??? How do foreign exceptions fit in?  As far as I can
-	      // see we can't match because there's no __cxa_exception
-	      // object to stuff bits in for __cxa_call_unexpected to use.
-	      // Allow them iff the exception spec is non-empty.  I.e.
-	      // a throw() specification results in __unexpected.
-	      if ((throw_type
-		   && !(actions & _UA_FORCE_UNWIND)
-		   && !foreign_exception)
-		  ? ! check_exception_spec (&info, throw_type, thrown_ptr,
-					    ar_filter)
-		  : empty_exception_spec (&info, ar_filter))
-		{
-		  saw_handler = true;
-		  break;
-		}
-	    }
-
-	  if (ar_disp == 0)
-	    break;
-	  action_record = p + ar_disp;
-	}
-
-      if (saw_handler)
-	{
-	  handler_switch_value = ar_filter;
-	  found_type = found_handler;
-	}
-      else
-	found_type = (saw_cleanup ? found_cleanup : found_nothing);
-    }
-
- do_something:
-   if (found_type == found_nothing)
-     CONTINUE_UNWINDING;
-
-  if (actions & _UA_SEARCH_PHASE)
-    {
-      if (found_type == found_cleanup)
-	CONTINUE_UNWINDING;
-
-      // For domestic exceptions, we cache data from phase 1 for phase 2.
-      if (!foreign_exception)
-        {
-	  save_caught_exception(ue_header, context, thrown_ptr,
-				handler_switch_value, language_specific_data,
-				landing_pad, action_record);
-	}
-      return _URC_HANDLER_FOUND;
-    }
-
- install_context:
-  
-  // We can't use any of the cxa routines with foreign exceptions,
-  // because they all expect ue_header to be a struct __cxa_exception.
-  // So in that case, call terminate or unexpected directly.
-  if ((actions & _UA_FORCE_UNWIND)
-      || foreign_exception)
-    {
-      if (found_type == found_terminate)
-	std::terminate ();
-      else if (handler_switch_value < 0)
-	{
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-	  __try
-	    { std::unexpected (); }
-	  __catch(...)
-	    { std::terminate (); }
-#pragma GCC diagnostic pop
-	}
-    }
-  else
-    {
-      if (found_type == found_terminate)
-	__cxa_call_terminate(ue_header);
-
-      // Cache the TType base value for __cxa_call_unexpected, as we won't
-      // have an _Unwind_Context then.
-      if (handler_switch_value < 0)
-	{
-	  parse_lsda_header (context, language_specific_data, &info);
-	  info.ttype_base = base_of_encoded_value (info.ttype_encoding,
-						   context);
-
-#ifdef __ARM_EABI_UNWINDER__
-	  const _Unwind_Word* e;
-	  _Unwind_Word n;
-	  
-	  e = ((const _Unwind_Word*) info.TType) - handler_switch_value - 1;
-	  // Count the number of rtti objects.
-	  n = 0;
-	  while (e[n] != 0)
-	    n++;
-
-	  // Count.
-	  ue_header->barrier_cache.bitpattern[1] = n;
-	  // Base
-	  ue_header->barrier_cache.bitpattern[2] = info.ttype_base;
-	  // Stride.
-	  ue_header->barrier_cache.bitpattern[3] = 4;
-	  // List head.
-	  ue_header->barrier_cache.bitpattern[4] = (_Unwind_Word) e;
-#else
-	  xh->catchTemp = base_of_encoded_value (info.ttype_encoding, context);
-#endif
-	}
-    }
-
-  /* For targets with pointers smaller than the word size, we must extend the
-     pointer, and this extension is target dependent.  */
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),
-		 __builtin_extend_pointer (ue_header));
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),
-		 handler_switch_value);
-  _Unwind_SetIP (context, landing_pad);
-#ifdef __ARM_EABI_UNWINDER__
-  if (found_type == found_cleanup)
-    __cxa_begin_cleanup(ue_header);
-#endif
-  return _URC_INSTALL_CONTEXT;
-}
-
 /* The ARM EABI implementation of __cxa_call_unexpected is in a
    different file so that the personality routine (PR) can be used
    standalone.  The generic routine shared datastructures with the PR
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/libsupc++/Makefile.am gcc-new/libstdc++-v3/libsupc++/Makefile.am
--- gcc-13.2.0/libstdc++-v3/libsupc++/Makefile.am	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/libsupc++/Makefile.am	2024-06-29 08:24:35.054382501 -0700
@@ -65,6 +65,7 @@
 	eh_alloc.cc \
 	eh_arm.cc \
 	eh_aux_runtime.cc \
+  eh_avr.cc \
 	eh_call.cc \
 	eh_catch.cc \
 	eh_exception.cc \
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/libsupc++/Makefile.in gcc-new/libstdc++-v3/libsupc++/Makefile.in
--- gcc-13.2.0/libstdc++-v3/libsupc++/Makefile.in	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/libsupc++/Makefile.in	2024-06-28 18:41:43.556778759 -0700
@@ -155,7 +155,7 @@
 	atomicity.lo bad_alloc.lo bad_array_length.lo bad_array_new.lo \
 	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
 	del_ops.lo del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo \
-	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_avr.lo eh_call.lo \
 	eh_catch.lo eh_exception.lo eh_globals.lo eh_personality.lo \
 	eh_ptr.lo eh_term_handler.lo eh_terminate.lo eh_tm.lo \
 	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
@@ -528,6 +528,7 @@
 	eh_alloc.cc \
 	eh_arm.cc \
 	eh_aux_runtime.cc \
+  eh_avr.cc \
 	eh_call.cc \
 	eh_catch.cc \
 	eh_exception.cc \
diff -ruN '--exclude=compile_commands.json' '--exclude=.git' '--exclude=obj' gcc-13.2.0/libstdc++-v3/src/c++98/math_stubs_long_double.cc gcc-new/libstdc++-v3/src/c++98/math_stubs_long_double.cc
--- gcc-13.2.0/libstdc++-v3/src/c++98/math_stubs_long_double.cc	2023-07-27 01:13:08.000000000 -0700
+++ gcc-new/libstdc++-v3/src/c++98/math_stubs_long_double.cc	2024-05-25 14:06:09.387714200 -0700
@@ -30,195 +30,195 @@
 
 extern "C"
 {
-#ifndef _GLIBCXX_HAVE_FABSL
-  long double
-  fabsl(long double x)
-  {
-    return fabs((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ACOSL
-  long double
-  acosl(long double x)
-  {
-    return acos((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ASINL
-  long double
-  asinl(long double x)
-  {
-    return asin((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ATANL
-  long double
-  atanl(long double x)
-  {
-    return atan ((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ATAN2L
-  long double
-  atan2l(long double x, long double y)
-  {
-    return atan2((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_CEILL
-  long double
-  ceill(long double x)
-  {
-    return ceil((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_COSL
-  long double
-  cosl(long double x)
-  {
-    return cos((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_COSHL
-  long double
-  coshl(long double x)
-  {
-    return cosh((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_EXPL
-  long double
-  expl(long double x)
-  {
-    return exp((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FLOORL
-  long double
-  floorl(long double x)
-  {
-    return floor((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FMODL
-  long double
-  fmodl(long double x, long double y)
-  {
-    return fmod((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FREXPL
-  long double
-  frexpl(long double x, int *exp)
-  {
-    return frexp((double) x, exp);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SQRTL
-  long double
-  sqrtl(long double x)
-  {
-    return  sqrt((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_HYPOTL
-  long double
-  hypotl(long double x, long double y)
-  {
-    long double s = fabsl(x) + fabsl(y);
-    if (s == 0.0L)
-      return s;
-    x /= s; y /= s;
-    return s * sqrtl(x * x + y * y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LDEXPL
-  long double
-  ldexpl(long double x, int exp)
-  {
-    return ldexp((double) x, exp);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LOGL
-  long double
-  logl(long double x)
-  {
-    return log((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LOG10L
-  long double
-  log10l(long double x)
-  {
-    return log10((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_MODFL
-  long double
-  modfl(long double x, long double *iptr)
-  {
-    double result, temp;
-
-    result = modf((double) x, &temp);
-    *iptr = temp;
-    return result;
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_POWL
-  long double
-  powl(long double x, long double y)
-  {
-    return pow((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SINL
-  long double
-  sinl(long double x)
-  {
-    return sin((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SINHL
-  long double
-  sinhl(long double x)
-  {
-    return sinh((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_TANL
-  long double
-  tanl(long double x)
-  {
-    return tan((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_TANHL
-  long double
-  tanhl(long double x)
-  {
-    return tanh((double) x);
-  }
-#endif
+// #ifndef _GLIBCXX_HAVE_FABSL
+//   long double
+//   fabsl(long double x)
+//   {
+//     return fabs((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ACOSL
+//   long double
+//   acosl(long double x)
+//   {
+//     return acos((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ASINL
+//   long double
+//   asinl(long double x)
+//   {
+//     return asin((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ATANL
+//   long double
+//   atanl(long double x)
+//   {
+//     return atan ((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ATAN2L
+//   long double
+//   atan2l(long double x, long double y)
+//   {
+//     return atan2((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_CEILL
+//   long double
+//   ceill(long double x)
+//   {
+//     return ceil((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_COSL
+//   long double
+//   cosl(long double x)
+//   {
+//     return cos((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_COSHL
+//   long double
+//   coshl(long double x)
+//   {
+//     return cosh((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_EXPL
+//   long double
+//   expl(long double x)
+//   {
+//     return exp((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FLOORL
+//   long double
+//   floorl(long double x)
+//   {
+//     return floor((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FMODL
+//   long double
+//   fmodl(long double x, long double y)
+//   {
+//     return fmod((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FREXPL
+//   long double
+//   frexpl(long double x, int *exp)
+//   {
+//     return frexp((double) x, exp);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SQRTL
+//   long double
+//   sqrtl(long double x)
+//   {
+//     return  sqrt((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_HYPOTL
+//   long double
+//   hypotl(long double x, long double y)
+//   {
+//     long double s = fabsl(x) + fabsl(y);
+//     if (s == 0.0L)
+//       return s;
+//     x /= s; y /= s;
+//     return s * sqrtl(x * x + y * y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LDEXPL
+//   long double
+//   ldexpl(long double x, int exp)
+//   {
+//     return ldexp((double) x, exp);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LOGL
+//   long double
+//   logl(long double x)
+//   {
+//     return log((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LOG10L
+//   long double
+//   log10l(long double x)
+//   {
+//     return log10((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_MODFL
+//   long double
+//   modfl(long double x, long double *iptr)
+//   {
+//     double result, temp;
+
+//     result = modf((double) x, &temp);
+//     *iptr = temp;
+//     return result;
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_POWL
+//   long double
+//   powl(long double x, long double y)
+//   {
+//     return pow((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SINL
+//   long double
+//   sinl(long double x)
+//   {
+//     return sin((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SINHL
+//   long double
+//   sinhl(long double x)
+//   {
+//     return sinh((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_TANL
+//   long double
+//   tanl(long double x)
+//   {
+//     return tan((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_TANHL
+//   long double
+//   tanhl(long double x)
+//   {
+//     return tanh((double) x);
+//   }
+// #endif
 } // extern "C"
