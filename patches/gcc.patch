From 5fc0d82a98fb23a8e1c7a658b411e99ec3f45ca8 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sat, 2 Nov 2024 19:20:11 -0700
Subject: [PATCH 01/11] move patches to 13.2.0 release instead of random
 release

---
 gcc/common/config/avr/avr-common.cc           |  12 +-
 gcc/config/avr/avr-protos.h                   |   5 +
 gcc/config/avr/avr.cc                         | 278 ++++++++++++
 gcc/config/avr/avr.h                          |  16 +-
 gcc/config/avr/elf.h                          |  14 +-
 gcc/config/avr/specs.h                        |   5 +-
 libgcc/config/avr/fae.h                       |  93 ++++
 libgcc/config/avr/t-avr                       |   2 +
 libgcc/config/avr/unwind-avr-sup.c            |  40 ++
 libgcc/config/avr/unwind-avr.S                | 243 +++++++++++
 libstdc++-v3/config/cpu/avr/atomic_word.h     |  40 ++
 .../cpu/avr/atomicity_builtins/atomicity.h    |  44 ++
 .../cpu/avr/atomicity_mutex/atomicity.h       |  59 +++
 libstdc++-v3/config/cpu/avr/cpu_defines.h     |  33 ++
 libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h   |  59 +++
 .../config/cpu/avr/opt/bits/opt_random.h      |  38 ++
 .../config/cpu/avr/opt/ext/opt_random.h       |  38 ++
 libstdc++-v3/config/os/avrlibc/ctype_base.h   |  59 +++
 .../config/os/avrlibc/ctype_configure_char.cc |  99 +++++
 libstdc++-v3/config/os/avrlibc/ctype_inline.h | 173 ++++++++
 .../config/os/avrlibc/error_constants.h       | 180 ++++++++
 libstdc++-v3/config/os/avrlibc/os_defines.h   |  41 ++
 .../config/os/newlib/ctype_configure_char.cc  |   2 +-
 libstdc++-v3/crossconfig.m4                   |  23 +
 libstdc++-v3/include/c_global/cmath           |   1 +
 libstdc++-v3/libsupc++/Makefile.am            |   1 +
 libstdc++-v3/libsupc++/Makefile.in            |   3 +-
 libstdc++-v3/libsupc++/eh_avr.cc              | 169 ++++++++
 libstdc++-v3/libsupc++/eh_personality.cc      | 400 ------------------
 .../src/c++98/math_stubs_long_double.cc       | 382 ++++++++---------
 30 files changed, 1951 insertions(+), 601 deletions(-)
 create mode 100644 libgcc/config/avr/fae.h
 create mode 100644 libgcc/config/avr/unwind-avr-sup.c
 create mode 100644 libgcc/config/avr/unwind-avr.S
 create mode 100644 libstdc++-v3/config/cpu/avr/atomic_word.h
 create mode 100644 libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h
 create mode 100644 libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h
 create mode 100644 libstdc++-v3/config/cpu/avr/cpu_defines.h
 create mode 100644 libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h
 create mode 100644 libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h
 create mode 100644 libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h
 create mode 100644 libstdc++-v3/config/os/avrlibc/ctype_base.h
 create mode 100644 libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc
 create mode 100644 libstdc++-v3/config/os/avrlibc/ctype_inline.h
 create mode 100644 libstdc++-v3/config/os/avrlibc/error_constants.h
 create mode 100644 libstdc++-v3/config/os/avrlibc/os_defines.h
 create mode 100644 libstdc++-v3/libsupc++/eh_avr.cc

diff --git a/gcc/common/config/avr/avr-common.cc b/gcc/common/config/avr/avr-common.cc
index 2f874c5b81c..1eaedfbfaa7 100644
--- a/gcc/common/config/avr/avr-common.cc
+++ b/gcc/common/config/avr/avr-common.cc
@@ -135,6 +135,16 @@ avr_handle_option (struct gcc_options *opts, struct gcc_options*,
 }
 
 
+enum unwind_info_type
+avr_except_unwind_info (struct gcc_options *opts)
+{
+  if (!opts->x_flag_exceptions && !opts->x_flag_unwind_tables)
+return UI_NONE;
+  else
+return UI_TARGET;
+}
+
+
 #undef TARGET_HANDLE_OPTION
 #define TARGET_HANDLE_OPTION avr_handle_option
 
@@ -142,6 +152,6 @@ avr_handle_option (struct gcc_options *opts, struct gcc_options*,
 #define TARGET_OPTION_OPTIMIZATION_TABLE avr_option_optimization_table
 
 #undef TARGET_EXCEPT_UNWIND_INFO
-#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info
+#define TARGET_EXCEPT_UNWIND_INFO avr_except_unwind_info
 
 struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
diff --git a/gcc/config/avr/avr-protos.h b/gcc/config/avr/avr-protos.h
index cf45a8c4499..242946b87a4 100644
--- a/gcc/config/avr/avr-protos.h
+++ b/gcc/config/avr/avr-protos.h
@@ -32,6 +32,10 @@ extern rtx avr_return_addr_rtx (int count, rtx tem);
 extern void avr_register_target_pragmas (void);
 extern void avr_init_expanders (void);
 
+extern void avr_asm_declare_function_name (FILE *, const char *, tree);
+extern void avr_output_fn_unwind (FILE *, bool prologue);
+extern enum unwind_info_type avr_except_unwind_info (struct gcc_options *opts);
+
 #ifdef TREE_CODE
 extern void avr_asm_output_aligned_decl_common (FILE*, tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);
 extern void avr_asm_asm_output_aligned_bss (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int, void (*) (FILE *, tree, const char *, unsigned HOST_WIDE_INT, int));
@@ -84,6 +88,7 @@ extern rtx avr_to_int_mode (rtx);
 
 extern void avr_expand_prologue (void);
 extern void avr_expand_epilogue (bool);
+extern rtx avr_eh_return_handler_rtx (void);
 extern bool avr_emit_cpymemhi (rtx*);
 extern int avr_epilogue_uses (int regno);
 
diff --git a/gcc/config/avr/avr.cc b/gcc/config/avr/avr.cc
index a5c628134b4..488e52f6a5d 100644
--- a/gcc/config/avr/avr.cc
+++ b/gcc/config/avr/avr.cc
@@ -1490,6 +1490,271 @@ avr_set_current_function (tree decl)
 }
 
 
+/* Implement ASM_DECLARE_FUNCTION_NAME on AVR */
+
+void
+avr_asm_declare_function_name (FILE *file, const char *name, tree)
+{
+  ASM_OUTPUT_TYPE_DIRECTIVE (file, name, "function");
+  ASM_OUTPUT_LABEL (file, name);
+
+  AVR_OUTPUT_FN_UNWIND (file, TRUE);
+}
+
+
+/* Emit unwind information for AVR */
+void
+avr_output_fn_unwind (FILE * f, bool prologue)
+{
+  if (avr_except_unwind_info (&global_options) != UI_TARGET)
+    return;
+
+  if (prologue){
+     /* If this function will never be unwound, then mark it as such.
+         The same condition is used in arm_unwind_emit to suppress
+   the frame annotations.  */
+      if (!(flag_unwind_tables || crtl->uses_eh_lsda)
+    && (TREE_NOTHROW (current_function_decl)
+        || crtl->all_throwers_are_sibcalls))
+  fputs("\t.cantunwind\n", f);
+      fputs ("\t.fnstart\n", f);}
+  else
+    {
+     
+
+      fputs ("\t.fnend\n", f);
+    }
+}
+
+/*  Emit unwind directives for a SET.  */
+
+static void
+avr_unwind_emit_set (FILE * out_file, rtx p)
+{
+  rtx e0;
+  rtx e1;
+  unsigned reg;
+
+  e0 = XEXP (p, 0);
+  e1 = XEXP (p, 1);
+  switch (GET_CODE (e0))
+  {
+    case MEM:
+      /* Pushing a single register.  */
+      if (GET_CODE (XEXP (e0, 0)) != POST_DEC
+        || !REG_P (XEXP (XEXP (e0, 0), 0))
+        || REGNO (XEXP (XEXP (e0, 0), 0)) != REG_SP)
+          abort ();
+
+      asm_fprintf (out_file, "\t.save %R%u\n", REGNO (e1));
+      // asm_fprintf(out_file, "%R%u\n", REGNO (e1));
+          break;
+
+    case REG:
+      if (REGNO (e0) == REG_SP)
+      {
+        /* A stack increment.  */
+        if (GET_CODE (e1) != PLUS
+            || !REG_P (XEXP (e1, 0))
+            || REGNO (XEXP (e1, 0)) != REG_SP
+            || !CONST_INT_P (XEXP (e1, 1)))
+          abort ();
+
+        asm_fprintf (out_file, "\t.pad %wd\n",
+               -INTVAL (XEXP (e1, 1)));
+      }
+      else if (REGNO (e0) == HARD_FRAME_POINTER_REGNUM)
+      {
+        HOST_WIDE_INT offset;
+
+        if (GET_CODE (e1) == PLUS)
+          {
+            if (!REG_P (XEXP (e1, 0))
+              || !CONST_INT_P (XEXP (e1, 1)))
+              abort ();
+            reg = REGNO (XEXP (e1, 0));
+            offset = INTVAL (XEXP (e1, 1));
+            asm_fprintf (out_file, "\t.setfp %r, %r, #%wd\n",
+             HARD_FRAME_POINTER_REGNUM, reg,
+             offset);
+          }
+        else if (REG_P (e1))
+          {
+            reg = REGNO (e1);
+            asm_fprintf (out_file, "\t.setfp %r, %r\n",
+             HARD_FRAME_POINTER_REGNUM, reg);
+          }
+        else
+          abort ();
+      }
+      else if (REG_P (e1) && REGNO (e1) == REG_SP)
+      {
+        /* Move from sp to reg.  */
+        asm_fprintf (out_file, "\t.movsp %r\n", REGNO (e0));
+      }
+      else if (GET_CODE (e1) == PLUS
+        && REG_P (XEXP (e1, 0))
+        && REGNO (XEXP (e1, 0)) == REG_SP
+        && CONST_INT_P (XEXP (e1, 1)))
+      {
+        /* Set reg to offset from sp.  */
+        asm_fprintf (out_file, "\t.movsp %r, #%d\n",
+               REGNO (e0), (int)INTVAL(XEXP (e1, 1)));
+      }
+      else
+        abort ();
+      break;
+
+    default:
+      abort ();
+  }
+}
+
+
+
+/* This function includes a lot of defensive programming, which
+   really should be moved to a unit test out of the main program. */
+static void
+avr_unwind_emit (FILE * out_file, rtx_insn *insn)
+{
+  rtx note, pat;
+  bool handled_one = false;
+  int last_offset = 1;
+
+  if (avr_except_unwind_info (&global_options) != UI_TARGET)
+    return;
+
+  if (!(flag_unwind_tables || crtl->uses_eh_lsda)
+      && (TREE_NOTHROW (current_function_decl)
+    || crtl->all_throwers_are_sibcalls))
+    return;
+
+  if (NOTE_P (insn) || !RTX_FRAME_RELATED_P (insn))
+    return;
+
+  for (note = REG_NOTES (insn); note ; note = XEXP (note, 1))
+    {
+      switch (REG_NOTE_KIND (note))
+  {
+  case REG_FRAME_RELATED_EXPR:
+    pat = XEXP (note, 0);
+    goto found;
+
+  case REG_CFA_REGISTER:
+    pat = XEXP (note, 0);
+    if (pat == NULL)
+      {
+        pat = PATTERN (insn);
+        if (GET_CODE (pat) == PARALLEL)
+          pat = XVECEXP (pat, 0, 0);
+      }
+
+    /* Only emitted for IS_STACKALIGN re-alignment.  */
+    {
+      rtx dest, src;
+      unsigned reg;
+
+      src = SET_SRC (pat);
+      dest = SET_DEST (pat);
+
+      gcc_assert (src == stack_pointer_rtx);
+      reg = REGNO (dest);
+
+        asm_fprintf (out_file, "\t.unwind_raw 0, 0x%x @ vsp = r%d\n",
+         reg + 0x90, reg);
+    }
+    handled_one = true;
+    break;
+
+  /* The INSN is generated in epilogue.  It is set as RTX_FRAME_RELATED_P
+     to get correct dwarf information for shrink-wrap.  We should not
+     emit unwind information for it because these are used either for
+     pretend arguments or notes to adjust sp and restore registers from
+     stack.  */
+  case REG_CFA_ADJUST_CFA:
+    {
+      pat = XEXP(note, 0);
+      if(GET_CODE(pat) != SET)
+        gcc_unreachable();
+      // r28 is literally the only base pointer allowed,
+      // and because of how AVR does things a base pointer
+      // is always necessary when adjusting the sp, so
+      // this is always true
+      asm_fprintf (out_file, "\t.setfp 28\n");
+
+      rtx e1 = XEXP(pat, 1);
+      if(GET_CODE(e1) != PLUS)
+        return;
+      rtx e1_1 = XEXP(e1, 1);
+      long stack_size = XINT(e1_1, 0);
+      if(stack_size > 0)
+        gcc_unreachable();
+      asm_fprintf (out_file, "\t.pad %ld\n", -stack_size + (last_offset-1));
+      return;
+    }
+  case REG_CFA_OFFSET:{
+      pat = XEXP(note, 0);
+      if(GET_CODE (pat) != SET)
+        gcc_unreachable();
+      rtx e0 = XEXP(pat, 0);
+      rtx e0_0 = XEXP(e0, 0);
+      int offset;
+      if(GET_CODE(e0_0) == REG){
+        // checks if register is SP_L
+        if(XINT(e0_0, 0) != 32)
+          gcc_unreachable();
+        offset = 0;
+      }else if(GET_CODE(e0_0) == PLUS){
+        rtx addant = XEXP(e0_0, 1);
+        if(GET_CODE(addant) != CONST_INT)
+          gcc_unreachable();
+        offset = XINT(addant, 0);
+      }else{
+        gcc_unreachable();
+      }
+      rtx e1 = XEXP(pat, 1);
+      if(GET_CODE(e1) != REG)
+        gcc_unreachable();
+      int reg = XINT(e1, 0);
+      // maintains that registers in descending order
+      if(last_offset -1 != offset)
+        gcc_unreachable();
+      asm_fprintf (out_file, "\t.save %R%u\n", reg);
+      last_offset = offset;
+      continue;
+  }
+  case REG_CFA_DEF_CFA:
+  case REG_CFA_RESTORE:
+    return;
+
+  case REG_CFA_EXPRESSION:
+    /* ??? Only handling here what we actually emit.  */
+    gcc_unreachable ();
+
+  default:
+    break;
+  }
+    }
+  if (handled_one){
+      return;
+  }
+  pat = PATTERN (insn);
+ found:
+
+  switch (GET_CODE (pat))
+    {
+    case PARALLEL:
+      // ignore it and hope for the best
+      break;
+    case SET:
+      avr_unwind_emit_set (out_file, pat);
+      break;
+
+    default:
+      abort();
+    }
+}
+
 /* Implement `ACCUMULATE_OUTGOING_ARGS'.  */
 
 int
@@ -13638,6 +13903,16 @@ avr_convert_to_type (tree type, tree expr)
   return NULL_TREE;
 }
 
+/* Implements EH_RETURN_HANDLER_RTX */
+rtx
+avr_eh_return_handler_rtx (void)
+{
+  rtx tmp = avr_incoming_return_addr_rtx();
+
+  /* Mark the store volatile, so no optimization is permitted to remove it.  */
+  MEM_VOLATILE_P (tmp) = true;
+  return tmp;
+}
 
 /* Implement `TARGET_LEGITIMATE_COMBINED_INSN'.  */
 
@@ -15239,6 +15514,9 @@ avr_float_lib_compare_returns_bool (machine_mode mode, enum rtx_code)
 #undef  TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID
 #define TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID avr_addr_space_zero_address_valid
 
+#undef TARGET_ASM_UNWIND_EMIT
+#define TARGET_ASM_UNWIND_EMIT avr_unwind_emit
+
 #undef  TARGET_MODE_DEPENDENT_ADDRESS_P
 #define TARGET_MODE_DEPENDENT_ADDRESS_P avr_mode_dependent_address_p
 
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 9939ab6ee77..3c5da955dd8 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -387,6 +387,8 @@ typedef struct avr_args
    There are no shared libraries on this target, and these sections are
    placed in the read-only program memory, so they are not writable.  */
 
+#define INIT_SECTION_ASM_OP "\t.section\t.init"
+
 #undef CTORS_SECTION_ASM_OP
 #define CTORS_SECTION_ASM_OP "\t.section .ctors,\"a\",@progbits"
 
@@ -517,9 +519,6 @@ extern const char *avr_no_devlib (int, const char**);
   " %:double-lib(%{m*:m%*})"                            \
   " %:device-specs-file(device-specs%s %{mmcu=*:%*})"
 
-/* No libstdc++ for now.  Empty string doesn't work.  */
-#define LIBSTDCXX "gcc"
-
 /* This is the default without any -mmcu=* option.  */
 #define MULTILIB_DEFAULTS { "mmcu=" AVR_MMCU_DEFAULT }
 
@@ -528,8 +527,19 @@ extern const char *avr_no_devlib (int, const char**);
 
 #define CR_TAB "\n\t"
 
+/* Used to define how dwarf exception handling is implemented. */
+#define EH_RETURN_DATA_REGNO(N) ((26 - (N+1) * 2) >= 20 ? (26 - (N+1) * 2) : INVALID_REGNUM)
+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 24)
+  
+/* This might have to be changed to pcrel if the pointer is not big enough */
+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)           (DW_EH_PE_absptr)
+#define EH_RETURN_HANDLER_RTX avr_eh_return_handler_rtx ()
+
+
 #define DWARF2_ADDR_SIZE 4
 
+#define AVR_OUTPUT_FN_UNWIND(F, PROLOGUE) avr_output_fn_unwind (F, PROLOGUE)
+
 #define INCOMING_RETURN_ADDR_RTX   avr_incoming_return_addr_rtx ()
 #define INCOMING_FRAME_SP_OFFSET   (AVR_3_BYTE_PC ? 3 : 2)
 
diff --git a/gcc/config/avr/elf.h b/gcc/config/avr/elf.h
index 86be435319e..0d1d3b3b36c 100644
--- a/gcc/config/avr/elf.h
+++ b/gcc/config/avr/elf.h
@@ -28,6 +28,16 @@
 #undef STRING_LIMIT
 #define STRING_LIMIT ((unsigned) 64)
 
+#undef  ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME avr_asm_declare_function_name
+#undef  ASM_DECLARE_FUNCTION_SIZE
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)     \
+  do                       \
+    {                      \
+      AVR_OUTPUT_FN_UNWIND (FILE, FALSE);       \
+      if (!flag_inhibit_size_directive)            \
+   ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);         \
+    }                      \
+  while (0)
 /* Be conservative in crtstuff.c.  */
-#undef INIT_SECTION_ASM_OP
-#undef FINI_SECTION_ASM_OP
+
diff --git a/gcc/config/avr/specs.h b/gcc/config/avr/specs.h
index b4a5ee6e5fc..1a4fdb9c0b5 100644
--- a/gcc/config/avr/specs.h
+++ b/gcc/config/avr/specs.h
@@ -40,9 +40,9 @@ along with GCC; see the file COPYING3.  If not see
 #undef  CC1PLUS_SPEC
 #define CC1PLUS_SPEC                                    \
   "%(cc1) "                                             \
-  "%{!frtti:-fno-rtti} "                                \
+  "%{!frtti:-frtti} "                                \
   "%{!fenforce-eh-specs:-fno-enforce-eh-specs} "        \
-  "%{!fexceptions:-fno-exceptions} "
+  "%{!fexceptions:-fexceptions} "
 
 #define ASM_RELAX_SPEC                          \
   "%{mrelax:--mlink-relax} "
@@ -78,3 +78,4 @@ along with GCC; see the file COPYING3.  If not see
 
 #define STARTFILE_SPEC ""
 #define ENDFILE_SPEC ""
+
diff --git a/libgcc/config/avr/fae.h b/libgcc/config/avr/fae.h
new file mode 100644
index 00000000000..78274630fd5
--- /dev/null
+++ b/libgcc/config/avr/fae.h
@@ -0,0 +1,93 @@
+#pragma once
+
+typedef unsigned char uint8_t;
+typedef unsigned int uint16_t;
+typedef int int16_t;
+
+#ifdef __FLASH
+typedef const uint8_t __flash prog_byte;
+#define __maybe_flash __flash
+#else
+typedef const uint8_t prog_byte;
+#define __maybe_flash
+#endif
+
+
+typedef struct personality_out{
+  uint16_t landing_pad;
+} personality_out;
+
+typedef uint8_t (*personality_routine)(prog_byte *ptr, uint16_t pc_offset, void *exc,
+                           personality_out *lp_out);
+
+typedef struct table_entry_t {
+  uint16_t pc_begin;
+  uint16_t pc_end;
+  prog_byte *data;
+  uint8_t frame_reg;
+  uint8_t length;
+  prog_byte *lsda;
+  personality_routine personality;
+} table_entry_t;
+
+/* Entries are aligned by 2 so that personality_ptr
+   can be read by a single movw instruction. Pad
+    using 0x00. Entries may be null terminated to
+    simplify debugging */
+
+// 0x00 is padding byte, should only occur at the end of the entry.
+// high bit is 0
+typedef struct skip {
+  uint8_t bytes;
+} skip;
+// skip make_skip(uint8_t b){return skip{ b & ~0b10000000};}
+
+typedef enum reg : uint8_t {
+  r2,
+  r3,
+  r4,
+  r5,
+  r6,
+  r7,
+  r8,
+  r9,
+  r10,
+  r11,
+  r12,
+  r13,
+  r14,
+  r15,
+  r16,
+  r17,
+  r28,
+  r29
+} reg;
+
+// high bit is 1
+typedef struct pop {
+  uint8_t _reg;
+} pop;
+
+inline uint8_t get_reg(pop p) { return p._reg & ~0b10000000; }
+inline pop make_pop(reg r) {
+  pop result;
+  result._reg = r | 0b10000000;
+  return result;
+}
+
+typedef union frame_inst {
+  pop p;
+  skip s;
+  uint8_t byte;
+} frame_inst;
+
+typedef struct table_data {
+  prog_byte *data;      // r18-19
+  prog_byte *data_end;  // r20-21
+  uint16_t landing_pad; // r22-23
+  uint8_t type_index;   // r24
+  uint8_t fp_register;   // r25
+} table_data;
+
+
+table_data __fae_get_ptr(void *except, uint16_t pc);
diff --git a/libgcc/config/avr/t-avr b/libgcc/config/avr/t-avr
index ed84b3f342e..0335608a4bb 100644
--- a/libgcc/config/avr/t-avr
+++ b/libgcc/config/avr/t-avr
@@ -294,3 +294,5 @@ LIB2FUNCS_EXCLUDE += \
 LIB2FUNCS_EXCLUDE += \
 	$(foreach func,_ssmul,\
 	$(foreach mode,$(ssmul_modes),$(func_X)))
+
+LIB2ADDEH = $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
diff --git a/libgcc/config/avr/unwind-avr-sup.c b/libgcc/config/avr/unwind-avr-sup.c
new file mode 100644
index 00000000000..694d684b879
--- /dev/null
+++ b/libgcc/config/avr/unwind-avr-sup.c
@@ -0,0 +1,40 @@
+#include "fae.h"
+
+extern prog_byte __fae_table_start[];
+extern prog_byte __fae_table_stop[];
+
+typedef const table_entry_t __maybe_flash * table_ptr;
+
+void __avr_terminate() __attribute__((noreturn));
+// no plans to implement forced unwinding
+void _Unwind_ForcedUnwind() { __avr_terminate(); }
+
+// returns data pointer for pc entry. If no entry is found, return 0
+table_data __fae_get_ptr(void *except, uint16_t pc) {
+  table_data result;
+  result.type_index = 0xff;
+
+  for (table_ptr ptr = __fae_table_start; ptr < __fae_table_stop; ptr++) {
+    if (ptr->pc_begin < pc && pc <= ptr->pc_end) {
+      result.data = ptr->data;
+      result.data_end = ptr->data + ptr->length;
+      result.fp_register = ptr->frame_reg;
+      if (ptr->lsda != 0) {
+        personality_out out = {};
+        result.type_index =
+            ptr->personality(ptr->lsda, (pc - ptr->pc_begin) * 2,
+                        except, &out);
+        result.landing_pad = out.landing_pad;
+        if (result.landing_pad == 0) {
+          result.type_index = 0xff;
+          return result;
+        }
+        result.landing_pad += ptr->pc_begin * 2;
+        result.landing_pad >>= 1;
+      }
+      return result;
+    }
+  }
+  result.data = 0;
+  return result;
+}
diff --git a/libgcc/config/avr/unwind-avr.S b/libgcc/config/avr/unwind-avr.S
new file mode 100644
index 00000000000..62a3660e429
--- /dev/null
+++ b/libgcc/config/avr/unwind-avr.S
@@ -0,0 +1,243 @@
+.file	"unwind-avr.S"
+
+#if defined (__AVR_TINY__)
+#define __zero_reg__ r17
+#define __tmp_reg__ r16
+#else
+#define __zero_reg__ r1
+#define __tmp_reg__ r0
+#endif
+#define __SREG__ 0x3f
+#if defined (__AVR_HAVE_SPH__)
+#define __SP_H__ 0x3e
+#endif
+#define __SP_L__ 0x3d
+#define __RAMPZ__ 0x3B
+#define __EIND__  0x3C
+
+#if defined (__AVR_HAVE_EIJMP_EICALL__) && !defined (__AVR_HAVE_ELPMX__)
+#error device not supported
+#endif
+
+  .macro  mov_l  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+  movw  \r_dest, \r_src
+#else
+  mov \r_dest, \r_src
+#endif
+  .endm
+
+  .macro  mov_h  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+  ; empty
+#else
+  mov \r_dest, \r_src
+#endif
+  .endm
+
+.macro  wmov  r_dest, r_src
+#if defined (__AVR_HAVE_MOVW__)
+    movw \r_dest,   \r_src
+#else
+    mov \r_dest,    \r_src
+    mov \r_dest+1,  \r_src+1
+#endif
+.endm
+
+#if defined (__AVR_HAVE_JMP_CALL__)
+#define XCALL call
+#define XJMP  jmp
+#else
+#define XCALL rcall
+#define XJMP  rjmp
+#endif
+
+#if defined (__AVR_HAVE_EIJMP_EICALL__)
+#define XICALL eicall
+#define XIJMP  eijmp
+#else
+#define XICALL icall
+#define XIJMP  ijmp
+#endif
+
+#define ZL 30
+#define ZH 31
+#define rZ 30
+
+
+#if defined (__AVR_HAVE_LPMX__)
+
+.data
+except_ptr:
+  .zero 2
+return_values:
+  .zero 8
+
+.text
+.global	_Unwind_Resume
+	.type	_Unwind_Resume, @function
+.global _Unwind_Resume_or_Rethrow ; resume_or_rethrow can be called from a forced_unwind,
+; I am not currently planning to implement forced unwinding
+	.type	_Unwind_Resume_or_Rethrow, @function
+
+.global	_Unwind_RaiseException
+	.type	_Unwind_RaiseException, @function
+
+unknown_func:
+  XCALL __avr_terminate ; std::terminate
+
+_Unwind_Resume_or_Rethrow:
+_Unwind_RaiseException:
+  sts except_ptr+1, r25
+  sts except_ptr, r24
+tailcall:
+  pop r23 ; read the return address
+  pop r22
+  lds r25, except_ptr+1
+  lds r24, except_ptr
+  XCALL __fae_get_ptr ; returns in r18-r23
+  ; r18 - data, r20 = end; r22 = landing_pad, r24 = type_index
+  cpi r18, 0 ; if no entry found
+  breq unknown_func ; std::terminate()
+  cpi r24, 0xff ; if no landing pad
+  breq no_landing_pad
+
+  cp r25, __zero_reg__ ;
+  breq goto_landing_pad ; if frame ptr is 0, do not restore bp
+  cpi r25, 28       ; base pointer is always r28 as defined in
+  brne unknown_func ; constraints.md
+  in r28, __SP_L__
+#if defined (__AVR_HAVE_SPH__)
+  in r29, __SP_H__
+#endif
+
+goto_landing_pad:
+  sts return_values,   r18
+  sts return_values+1, r19
+  sts return_values+2, r20
+  sts return_values+3, r21
+  in __tmp_reg__, __SP_H__
+  sts return_values+5, __tmp_reg__
+  in __tmp_reg__, __SP_L__
+  sts return_values+4, __tmp_reg__
+  sts return_values+6, r25
+  wmov rZ, 22 ; move landing_pad to Z
+  mov r22, r24 ; move type_index
+  lds r25, except_ptr+1
+  lds r24, except_ptr
+  XIJMP
+
+_Unwind_Resume:
+  lds r25, return_values+6
+  in __tmp_reg__, __SREG__
+  cli
+  lds r19, return_values+5
+  out __SP_H__, r19
+  lds r19, return_values+4
+  out __SREG__, __tmp_reg__
+  out __SP_L__, r19
+  lds r21, return_values+3
+  lds r20, return_values+2
+  lds r19, return_values+1
+  lds r18, return_values
+
+no_landing_pad:
+  cp r18, r20 ; if data = data_end, no unwind besides return
+  cpc r19, r21
+  breq unwind_ret
+  wmov rZ, 18
+
+unwind_loop:
+  cp r30, r20
+  cpc r31, r21
+  breq unwind_ret ; if Z == end, end loop
+  lpm r26, Z+
+  sbrc r26, 7 ; if high bit is clear, it must be a skip
+  XJMP is_pop ; else it is pop
+  cp r26, __zero_reg__ ; if skip is zero, exit loop
+  breq unwind_ret
+is_skip:
+  in r24, __SP_L__
+  in r25, __SP_H__
+  add r24, r26
+  adc r25, __zero_reg__
+  in __tmp_reg__, __SREG__
+  cli
+  out __SP_L__, r24
+  out __SREG__, __tmp_reg__
+  out __SP_H__, r25
+  XJMP unwind_loop
+unwind_ret:
+  XJMP tailcall
+; this part is actually suprisingly buggy
+; if there are weird 
+is_pop:
+  cbr r26, 0x80 ; clears high bit
+  wmov 18, rZ
+  ldi r31, 0
+  mov r30, r26
+  lsl r30 ; size of each jump is two instructions
+  ldi r27, lo8(pm(reg2))
+  add r30, r27
+  ldi r27, hi8(pm(reg2))
+  adc r31, r27
+  XIJMP
+reg2:
+  pop r2
+  rjmp end_pop
+reg3:
+  pop r3
+  rjmp end_pop
+reg4:
+  pop r4
+  rjmp end_pop
+reg5:
+  pop r5
+  rjmp end_pop
+reg6:
+  pop r6
+  rjmp end_pop
+reg7:
+  pop r7
+  rjmp end_pop
+reg8:
+  pop r8
+  rjmp end_pop
+reg9:
+  pop r9
+  rjmp end_pop
+reg10:
+  pop r10
+  rjmp end_pop
+reg11:
+  pop r11
+  rjmp end_pop
+reg12:
+  pop r12
+  rjmp end_pop
+reg13:
+  pop r13
+  rjmp end_pop
+reg14:
+  pop r14
+  rjmp end_pop
+reg15:
+  pop r15
+  rjmp end_pop
+reg16:
+  pop r16
+  rjmp end_pop
+reg17:
+  pop r17
+  rjmp end_pop
+reg28:
+  pop r28
+  rjmp end_pop
+reg29:
+  pop r29
+  rjmp end_pop
+end_pop:
+  wmov rZ, 18
+  XJMP unwind_loop
+
+#endif
\ No newline at end of file
diff --git a/libstdc++-v3/config/cpu/avr/atomic_word.h b/libstdc++-v3/config/cpu/avr/atomic_word.h
new file mode 100644
index 00000000000..301b99220b2
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/atomic_word.h
@@ -0,0 +1,40 @@
+// Low-level type for atomic operations -*- C++ -*-
+
+// Copyright (C) 2004-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file atomic_word.h
+ *  This file is a GNU extension to the Standard C++ Library.
+ */
+
+#ifndef _GLIBCXX_ATOMIC_WORD_H
+#define _GLIBCXX_ATOMIC_WORD_H	1
+
+typedef int _Atomic_word;
+
+
+// This is a memory order acquire fence.
+#define _GLIBCXX_READ_MEM_BARRIER __atomic_thread_fence (__ATOMIC_ACQUIRE)
+// This is a memory order release fence.
+#define _GLIBCXX_WRITE_MEM_BARRIER __atomic_thread_fence (__ATOMIC_RELEASE)
+
+#endif
diff --git a/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h b/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h
new file mode 100644
index 00000000000..016876b9281
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/atomicity_builtins/atomicity.h
@@ -0,0 +1,44 @@
+// Low-level functions for atomic operations: version for CPUs providing
+// atomic builtins -*- C++ -*-
+
+// Copyright (C) 2006-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <bits/c++config.h>
+#include <bits/atomic_word.h>
+
+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h b/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h
new file mode 100644
index 00000000000..33f16574aa6
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/atomicity_mutex/atomicity.h
@@ -0,0 +1,59 @@
+// Low-level functions for atomic operations: Generic version  -*- C++ -*-
+
+// Copyright (C) 1999-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <ext/atomicity.h>
+#include <ext/concurrence.h>
+
+namespace
+{
+  __gnu_cxx::__mutex&
+  get_atomic_mutex()
+  {
+    static __gnu_cxx::__mutex atomic_mutex;
+    return atomic_mutex;
+  }
+} // anonymous namespace
+
+namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  _Atomic_word
+  __attribute__ ((__unused__))
+  __exchange_and_add(volatile _Atomic_word* __mem, int __val) throw ()
+  {
+    __gnu_cxx::__scoped_lock sentry(get_atomic_mutex());
+    _Atomic_word __result;
+    __result = *__mem;
+    *__mem += __val;
+    return __result;
+  }
+
+  void
+  __attribute__ ((__unused__))
+  __atomic_add(volatile _Atomic_word* __mem, int __val) throw ()
+  { __exchange_and_add(__mem, __val); }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/cpu/avr/cpu_defines.h b/libstdc++-v3/config/cpu/avr/cpu_defines.h
new file mode 100644
index 00000000000..95edb404359
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/cpu_defines.h
@@ -0,0 +1,33 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2005-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/cpu_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_CPU_DEFINES
+#define _GLIBCXX_CPU_DEFINES 1
+
+#endif
diff --git a/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h b/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h
new file mode 100644
index 00000000000..9d524386eb0
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/cxxabi_tweaks.h
@@ -0,0 +1,59 @@
+// Control various target specific ABI tweaks.  Generic version.
+
+// Copyright (C) 2004-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/cxxabi_tweaks.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{cxxabi.h}
+ */
+
+#ifndef _CXXABI_TWEAKS_H
+#define _CXXABI_TWEAKS_H 1
+
+#ifdef __cplusplus
+namespace __cxxabiv1
+{
+  extern "C"
+  {
+#endif
+
+  // The generic ABI uses the first byte of a 64-bit guard variable.
+#define _GLIBCXX_GUARD_TEST(x) (*(char *) (x) != 0)
+#define _GLIBCXX_GUARD_SET(x) *(char *) (x) = 1
+#define _GLIBCXX_GUARD_BIT __guard_test_bit (0, 1)
+#define _GLIBCXX_GUARD_PENDING_BIT __guard_test_bit (1, 1)
+#define _GLIBCXX_GUARD_WAITING_BIT __guard_test_bit (2, 1)
+  __extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+  // __cxa_vec_ctor has void return type.
+  typedef void __cxa_vec_ctor_return_type;
+#define _GLIBCXX_CXA_VEC_CTOR_RETURN(x) return
+  // Constructors and destructors do not return a value.
+  typedef void __cxa_cdtor_return_type;
+
+#ifdef __cplusplus
+  }
+} // namespace __cxxabiv1
+#endif
+
+#endif
diff --git a/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h b/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h
new file mode 100644
index 00000000000..c32e677f912
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/opt/bits/opt_random.h
@@ -0,0 +1,38 @@
+// Optimizations for random number handling, generic version -*- C++ -*-
+
+// Copyright (C) 2012-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/opt_random.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{random}
+ */
+
+#ifndef _BITS_OPT_RANDOM_H
+#define _BITS_OPT_RANDOM_H 1
+
+#pragma GCC system_header
+
+
+
+
+#endif // _BITS_OPT_RANDOM_H
diff --git a/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h b/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h
new file mode 100644
index 00000000000..729e7b6d71b
--- /dev/null
+++ b/libstdc++-v3/config/cpu/avr/opt/ext/opt_random.h
@@ -0,0 +1,38 @@
+// Optimizations for random number extensions, generic version -*- C++ -*-
+
+// Copyright (C) 2012-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ext/opt_random.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{ext/random}
+ */
+
+#ifndef _EXT_OPT_RANDOM_H
+#define _EXT_OPT_RANDOM_H 1
+
+#pragma GCC system_header
+
+
+
+
+#endif // _EXT_OPT_RANDOM_H
diff --git a/libstdc++-v3/config/os/avrlibc/ctype_base.h b/libstdc++-v3/config/os/avrlibc/ctype_base.h
new file mode 100644
index 00000000000..b4fe105d441
--- /dev/null
+++ b/libstdc++-v3/config/os/avrlibc/ctype_base.h
@@ -0,0 +1,59 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 1997-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// Default information, may not be appropriate for specific host.
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// @brief  Base class for ctype.
+  struct ctype_base
+  {
+    // Non-standard typedefs.
+    typedef const int* 		__to_type;
+
+    // NB: Offsets into ctype<char>::_M_table force a particular size
+    // on the mask type. Because of this, we don't use an enum.
+    typedef unsigned int 	mask;
+    static const mask upper    	= 1 << 0;
+    static const mask lower 	= 1 << 1;
+    static const mask alpha 	= 1 << 2;
+    static const mask digit 	= 1 << 3;
+    static const mask xdigit 	= 1 << 4;
+    static const mask space 	= 1 << 5;
+    static const mask print 	= 1 << 6;
+    static const mask graph 	= (1 << 2) | (1 << 3) | (1 << 9); // alnum|punct
+    static const mask cntrl 	= 1 << 8;
+    static const mask punct 	= 1 << 9;
+    static const mask alnum 	= (1 << 2) | (1 << 3);  // alpha|digit
+    static const mask blank	= 1 << 10;
+  };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc b/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc
new file mode 100644
index 00000000000..8d1706d360a
--- /dev/null
+++ b/libstdc++-v3/config/os/avrlibc/ctype_configure_char.cc
@@ -0,0 +1,99 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2011-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file ctype_configure_char.cc */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+#include <locale>
+#include <cstdlib>
+#include <cstring>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+// Information as gleaned from /usr/include/ctype.h
+
+  const ctype_base::mask*
+  ctype<char>::classic_table() throw()
+  { return 0; }
+
+  ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
+		     size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  ctype<char>::ctype(const mask* __table, bool __del, size_t __refs)
+  : facet(__refs), _M_del(__table != 0 && __del),
+  _M_toupper(NULL), _M_tolower(NULL),
+  _M_table(__table ? __table : classic_table())
+  {
+    memset(_M_widen, 0, sizeof(_M_widen));
+    _M_widen_ok = 0;
+    memset(_M_narrow, 0, sizeof(_M_narrow));
+    _M_narrow_ok = 0;
+  }
+
+  char
+  ctype<char>::do_toupper(char __c) const
+  { return ::toupper((int) __c); }
+
+  const char*
+  ctype<char>::do_toupper(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::toupper((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+  char
+  ctype<char>::do_tolower(char __c) const
+  { return ::tolower((int) __c); }
+
+  const char*
+  ctype<char>::do_tolower(char* __low, const char* __high) const
+  {
+    while (__low < __high)
+      {
+	*__low = ::tolower((int) *__low);
+	++__low;
+      }
+    return __high;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/avrlibc/ctype_inline.h b/libstdc++-v3/config/os/avrlibc/ctype_inline.h
new file mode 100644
index 00000000000..07b66cf5951
--- /dev/null
+++ b/libstdc++-v3/config/os/avrlibc/ctype_inline.h
@@ -0,0 +1,173 @@
+// Locale support -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/ctype_inline.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{locale}
+ */
+
+//
+// ISO C++ 14882: 22.1  Locales
+//
+
+// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
+// functions go in ctype.cc
+
+// The following definitions are portable, but insanely slow. If one
+// cares at all about performance, then specialized ctype
+// functionality should be added for the native os in question: see
+// the config/os/bits/ctype_*.h files.
+
+// Constructing a synthetic "C" table should be seriously considered...
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  bool
+  ctype<char>::
+  is(mask __m, char __c) const
+  {
+    if (_M_table)
+      return _M_table[static_cast<unsigned char>(__c)] & __m;
+    else
+      {
+	bool __ret = false;
+	const size_t __bitmasksize = 15;
+	size_t __bitcur = 0; // Lowest bitmask in ctype_base == 0
+	for (; __bitcur <= __bitmasksize; ++__bitcur)
+	  {
+	    const mask __bit = static_cast<mask>(1 << __bitcur);
+	    if (__m & __bit)
+	      {
+		bool __testis;
+		switch (__bit)
+		  {
+		  case space:
+		    __testis = isspace(__c);
+		    break;
+		  case print:
+		    __testis = isprint(__c);
+		    break;
+		  case cntrl:
+		    __testis = iscntrl(__c);
+		    break;
+		  case upper:
+		    __testis = isupper(__c);
+		    break;
+		  case lower:
+		    __testis = islower(__c);
+		    break;
+		  case alpha:
+		    __testis = isalpha(__c);
+		    break;
+		  case digit:
+		    __testis = isdigit(__c);
+		    break;
+		  case punct:
+		    __testis = ispunct(__c);
+		    break;
+		  case xdigit:
+		    __testis = isxdigit(__c);
+		    break;
+		  case alnum:
+		    __testis = isalnum(__c);
+		    break;
+		  case graph:
+		    __testis = isgraph(__c);
+		    break;
+#ifdef _GLIBCXX_USE_C99_CTYPE_TR1
+		  case blank:
+		    __testis = isblank(__c);
+		    break;
+#endif
+		  default:
+		    __testis = false;
+		    break;
+		  }
+		__ret |= __testis;
+	      }
+	  }
+	return __ret;
+      }
+  }
+
+  const char*
+  ctype<char>::
+  is(const char* __low, const char* __high, mask* __vec) const
+  {
+    if (_M_table)
+      while (__low < __high)
+	*__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
+    else
+      {
+	// Highest bitmask in ctype_base == 11.
+	const size_t __bitmasksize = 15;
+	for (;__low < __high; ++__vec, ++__low)
+	  {
+	    mask __m = 0;
+	    // Lowest bitmask in ctype_base == 0
+	    size_t __i = 0;
+	    for (;__i <= __bitmasksize; ++__i)
+	      {
+		const mask __bit = static_cast<mask>(1 << __i);
+		if (this->is(__bit, *__low))
+		  __m |= __bit;
+	      }
+	    *__vec = __m;
+	  }
+      }
+    return __high;
+  }
+
+  const char*
+  ctype<char>::
+  scan_is(mask __m, const char* __low, const char* __high) const
+  {
+    if (_M_table)
+      while (__low < __high
+	     && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
+	++__low;
+    else
+      while (__low < __high && !this->is(__m, *__low))
+	++__low;
+    return __low;
+  }
+
+  const char*
+  ctype<char>::
+  scan_not(mask __m, const char* __low, const char* __high) const
+  {
+    if (_M_table)
+      while (__low < __high
+	     && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
+	++__low;
+    else
+      while (__low < __high && this->is(__m, *__low) != 0)
+	++__low;
+    return __low;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/config/os/avrlibc/error_constants.h b/libstdc++-v3/config/os/avrlibc/error_constants.h
new file mode 100644
index 00000000000..ba2795352bc
--- /dev/null
+++ b/libstdc++-v3/config/os/avrlibc/error_constants.h
@@ -0,0 +1,180 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2007-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/error_constants.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{system_error}
+ */
+
+#ifndef _GLIBCXX_ERROR_CONSTANTS
+#define _GLIBCXX_ERROR_CONSTANTS 1
+
+#include <bits/c++config.h>
+#include <cerrno>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  enum class errc
+    {
+      address_family_not_supported = 		EAFNOSUPPORT,
+      address_in_use = 				EADDRINUSE,
+      address_not_available = 			EADDRNOTAVAIL,
+      already_connected = 			EISCONN,
+      argument_list_too_long = 			E2BIG,
+      argument_out_of_domain = 			EDOM,
+      bad_address = 				EFAULT,
+      bad_file_descriptor = 			EBADF,
+
+#ifdef EBADMSG
+      bad_message = 				EBADMSG,
+#endif
+
+      broken_pipe = 				EPIPE,
+      connection_aborted = 			ECONNABORTED,
+      connection_already_in_progress = 		EALREADY,
+      connection_refused = 			ECONNREFUSED,
+      connection_reset = 			ECONNRESET,
+      cross_device_link = 			EXDEV,
+      destination_address_required = 		EDESTADDRREQ,
+      device_or_resource_busy = 		EBUSY,
+      directory_not_empty = 			ENOTEMPTY,
+      executable_format_error = 		ENOEXEC,
+      file_exists = 	       			EEXIST,
+      file_too_large = 				EFBIG,
+      filename_too_long = 			ENAMETOOLONG,
+      function_not_supported = 			ENOSYS,
+      host_unreachable = 			EHOSTUNREACH,
+
+#ifdef EIDRM
+      identifier_removed = 			EIDRM,
+#endif
+
+      illegal_byte_sequence = 			EILSEQ,
+      inappropriate_io_control_operation = 	ENOTTY,
+      interrupted = 				EINTR,
+      invalid_argument = 			EINVAL,
+      invalid_seek = 				ESPIPE,
+      io_error = 				EIO,
+      is_a_directory = 				EISDIR,
+      message_size = 				EMSGSIZE,
+      network_down = 				ENETDOWN,
+      network_reset = 				ENETRESET,
+      network_unreachable = 			ENETUNREACH,
+      no_buffer_space = 			ENOBUFS,
+      no_child_process = 			ECHILD,
+
+#ifdef ENOLINK
+      no_link = 				ENOLINK,
+#endif
+
+      no_lock_available = 			ENOLCK,
+
+#ifdef ENODATA
+      no_message_available = 			ENODATA,
+#endif
+
+      no_message = 				ENOMSG,
+      no_protocol_option = 			ENOPROTOOPT,
+      no_space_on_device = 			ENOSPC,
+
+#ifdef ENOSR
+      no_stream_resources = 			ENOSR,
+#endif
+
+      no_such_device_or_address = 		ENXIO,
+      no_such_device = 				ENODEV,
+      no_such_file_or_directory = 		ENOENT,
+      no_such_process = 			ESRCH,
+      not_a_directory = 			ENOTDIR,
+      not_a_socket = 				ENOTSOCK,
+
+#ifdef ENOSTR
+      not_a_stream = 				ENOSTR,
+#endif
+
+      not_connected = 				ENOTCONN,
+      not_enough_memory = 			ENOMEM,
+
+#ifdef ENOTSUP
+      not_supported = 				ENOTSUP,
+#endif
+
+#ifdef ECANCELED
+      operation_canceled = 			ECANCELED,
+#endif
+
+      operation_in_progress = 			EINPROGRESS,
+      operation_not_permitted = 		EPERM,
+      operation_not_supported = 		EOPNOTSUPP,
+      operation_would_block = 			EWOULDBLOCK,
+
+#ifdef EOWNERDEAD
+      owner_dead = 				EOWNERDEAD,
+#endif
+
+      permission_denied = 			EACCES,
+
+#ifdef EPROTO
+      protocol_error = 				EPROTO,
+#endif
+
+      protocol_not_supported = 			EPROTONOSUPPORT,
+      read_only_file_system = 			EROFS,
+      resource_deadlock_would_occur = 		EDEADLK,
+      resource_unavailable_try_again = 		EAGAIN,
+      result_out_of_range = 			ERANGE,
+
+#ifdef ENOTRECOVERABLE
+      state_not_recoverable = 			ENOTRECOVERABLE,
+#endif
+
+#ifdef ETIME
+      stream_timeout = 				ETIME,
+#endif
+
+#ifdef ETXTBSY
+      text_file_busy = 				ETXTBSY,
+#endif
+
+      timed_out = 				ETIMEDOUT,
+      too_many_files_open_in_system = 		ENFILE,
+      too_many_files_open = 			EMFILE,
+      too_many_links = 				EMLINK,
+      too_many_symbolic_link_levels = 		ELOOP,
+
+#ifdef EOVERFLOW
+      value_too_large = 			EOVERFLOW,
+#elif defined __AVR__
+      value_too_large = 			999,
+#endif
+
+      wrong_protocol_type = 			EPROTOTYPE
+    };
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
+
+#endif
diff --git a/libstdc++-v3/config/os/avrlibc/os_defines.h b/libstdc++-v3/config/os/avrlibc/os_defines.h
new file mode 100644
index 00000000000..62c149d7032
--- /dev/null
+++ b/libstdc++-v3/config/os/avrlibc/os_defines.h
@@ -0,0 +1,41 @@
+// Specific definitions for generic platforms  -*- C++ -*-
+
+// Copyright (C) 2000-2023 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/** @file bits/os_defines.h
+ *  This is an internal header file, included by other library headers.
+ *  Do not attempt to use it directly. @headername{iosfwd}
+ */
+
+#ifndef _GLIBCXX_OS_DEFINES
+#define _GLIBCXX_OS_DEFINES 1
+
+// System-specific #define, typedefs, corrections, etc, go here.  This
+// file will come before all others.
+
+// Disable the weak reference logic in gthr.h for os/generic because it
+// is broken on every platform unless there is implementation specific
+// workaround in gthr-posix.h and at link-time for static linking.
+#define _GLIBCXX_GTHREAD_USE_WEAK 0
+
+#endif
diff --git a/libstdc++-v3/config/os/newlib/ctype_configure_char.cc b/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
index 2f3727e5309..96404033687 100644
--- a/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
+++ b/libstdc++-v3/config/os/newlib/ctype_configure_char.cc
@@ -40,7 +40,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   const ctype_base::mask*
   ctype<char>::classic_table() throw()
-  { return _ctype_ + 1; }
+  { return 0; }
 
   ctype<char>::ctype(__c_locale, const mask* __table, bool __del,
 		     size_t __refs)
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
index b3269cb88e0..f4d76ad9363 100644
--- a/libstdc++-v3/crossconfig.m4
+++ b/libstdc++-v3/crossconfig.m4
@@ -33,6 +33,29 @@ case "${host}" in
     AC_DEFINE(HAVE_SINHF)
     AC_DEFINE(HAVE_TANF)
     AC_DEFINE(HAVE_TANHF)
+    AC_DEFINE(HAVE_ACOSL)
+    AC_DEFINE(HAVE_ASINL)
+    AC_DEFINE(HAVE_ATAN2L)
+    AC_DEFINE(HAVE_ATANL)
+    AC_DEFINE(HAVE_CEILL)
+    AC_DEFINE(HAVE_COSL)
+    AC_DEFINE(HAVE_COSHL)
+    AC_DEFINE(HAVE_EXPL)
+    AC_DEFINE(HAVE_FABSL)
+    AC_DEFINE(HAVE_FLOORL)
+    AC_DEFINE(HAVE_FMODL)
+    AC_DEFINE(HAVE_FREXPL)
+    AC_DEFINE(HAVE_LDEXPL)
+    AC_DEFINE(HAVE_LOG10L)
+    AC_DEFINE(HAVE_LOGL)
+    AC_DEFINE(HAVE_MODFL)
+    AC_DEFINE(HAVE_POWL)
+    AC_DEFINE(HAVE_SINCOSL)
+    AC_DEFINE(HAVE_SINL)
+    AC_DEFINE(HAVE_SINHL)
+    AC_DEFINE(HAVE_SQRTL)
+    AC_DEFINE(HAVE_TANL)
+    AC_DEFINE(HAVE_TANHL)
     ;;
 
   mips*-sde-elf*)
diff --git a/libstdc++-v3/include/c_global/cmath b/libstdc++-v3/include/c_global/cmath
index 992713b70da..a011fe0a2c7 100644
--- a/libstdc++-v3/include/c_global/cmath
+++ b/libstdc++-v3/include/c_global/cmath
@@ -83,6 +83,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
   using ::acos;
+  using ::isinf;
 
 #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
   inline _GLIBCXX_CONSTEXPR float
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index 2bd25211816..654a77902cf 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -65,6 +65,7 @@ sources = \
 	eh_alloc.cc \
 	eh_arm.cc \
 	eh_aux_runtime.cc \
+  eh_avr.cc \
 	eh_call.cc \
 	eh_catch.cc \
 	eh_exception.cc \
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 732ab89c8a2..7198f6c293f 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -155,7 +155,7 @@ am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \
 	atomicity.lo bad_alloc.lo bad_array_length.lo bad_array_new.lo \
 	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
 	del_ops.lo del_opnt.lo del_opv.lo del_opvs.lo del_opvnt.lo \
-	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo \
+	dyncast.lo eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_avr.lo eh_call.lo \
 	eh_catch.lo eh_exception.lo eh_globals.lo eh_personality.lo \
 	eh_ptr.lo eh_term_handler.lo eh_terminate.lo eh_tm.lo \
 	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
@@ -528,6 +528,7 @@ sources = \
 	eh_alloc.cc \
 	eh_arm.cc \
 	eh_aux_runtime.cc \
+  eh_avr.cc \
 	eh_call.cc \
 	eh_catch.cc \
 	eh_exception.cc \
diff --git a/libstdc++-v3/libsupc++/eh_avr.cc b/libstdc++-v3/libsupc++/eh_avr.cc
new file mode 100644
index 00000000000..152fb0e4660
--- /dev/null
+++ b/libstdc++-v3/libsupc++/eh_avr.cc
@@ -0,0 +1,169 @@
+#ifdef __AVR_ARCH__
+
+
+
+#include <bits/c++config.h>
+#include <bits/exception_defines.h>
+#include <cxxabi.h>
+#include "unwind-cxx.h"
+#include <cstdlib>
+
+#include <typeinfo>
+#include "unwind-pe.h"
+#include <avr/pgmspace.h>
+
+typedef unsigned char uint8_t;
+typedef unsigned int uint16_t;
+typedef int int16_t;
+
+namespace __cxxabiv1{
+static void *get_adjusted_ptr(const void *c, const std::type_info *t,
+                              void *thrown_ptr) noexcept {
+  auto catch_type = static_cast<const std::type_info *>(c);
+  auto throw_type = static_cast<const std::type_info *>(t);
+  if (throw_type->__is_pointer_p())
+    thrown_ptr = *(void **)thrown_ptr;
+
+  if (catch_type->__do_catch(throw_type, &thrown_ptr, 1)) {
+    return thrown_ptr;
+  }
+
+  return nullptr;
+}
+
+static void *get_adjusted_ptr(void *exc,
+                                        const void *catch_type) noexcept {
+  auto ue = static_cast<_Unwind_Exception *>(exc);
+  auto cxa_except = __get_exception_header_from_ue(ue);
+  auto thrown_obj = __get_object_from_ue(ue);
+  auto thrown_type = cxa_except->exceptionType;
+  cxa_except->adjustedPtr =
+      get_adjusted_ptr(catch_type, thrown_type, thrown_obj);
+  return cxa_except->adjustedPtr;
+}
+
+extern "C" void __avr_terminate() {
+  std::terminate();
+}
+
+typedef const uint8_t prog_byte;
+typedef void* void_ptr;
+typedef const void_ptr *prog_ptr;
+
+
+static uint8_t get(prog_byte* p){
+  return __LPM((unsigned)p);
+}
+
+static void* getw(prog_ptr p){
+  return (void*) __LPM_word((unsigned)p);
+}
+
+static uint8_t uleb(prog_byte *ptr, uint16_t *out) {
+  *out = get(ptr++);
+  if (!(*out & 0b10000000)) {
+    return 1;
+  } else {
+    *out &= 0b01111111;
+    if (get(ptr) & 0b00000001) {
+      *out |= 0b10000000;
+    }
+    *out |= get(ptr) << 7;
+    return 2;
+  }
+}
+
+
+static uint8_t sleb(prog_byte *ptr, int16_t *const val) {
+  int16_t i = 0;
+
+  uint8_t b = get(&ptr[i++]);
+  *val = b & 0b01111111;
+
+  if (b & 0b10000000) {
+    b = get(&ptr[i++]);
+    *val <<= 7;
+    *val |= b & 0b01111111;
+  }
+
+  if (b & 0x40) {
+    *val |= (-1ULL) << 7;
+    return i;
+  }
+  return i;
+}
+
+struct personality_out{
+  uint16_t landing_pad;
+};
+
+
+// this is very bad, and probably should be rewritten in assembly for speed/size
+extern "C" uint8_t __avr_cxx_personality(prog_byte *ptr, uint16_t pc_offset, void *exc,
+                           personality_out *out) noexcept {
+  uint8_t lp_encoding = get(ptr++);
+  uint16_t lp_offset = 0;
+  if (lp_encoding != DW_EH_PE_omit) {
+    // in reality lp offset never seems to be set. This should really
+    // consider if lp offset is set or not, but for now it works
+    ptr += uleb(ptr, &lp_offset);
+  }
+  uint8_t type_encoding = get(ptr++);
+  uint16_t types_offset = 0;
+  if (type_encoding != DW_EH_PE_omit) {
+    ptr += uleb(ptr, &types_offset);
+  }
+
+  prog_ptr type_table = reinterpret_cast<prog_ptr>(ptr + types_offset);
+  uint8_t call_encoding = get(ptr++);
+  uint16_t call_table_length;
+  ptr += uleb(ptr, &call_table_length);
+  if ((type_encoding != DW_EH_PE_absptr && type_encoding != DW_EH_PE_omit) ||
+      call_encoding != DW_EH_PE_uleb128) {
+    __avr_terminate();
+  }
+  prog_byte *end = ptr + call_table_length;
+  uint16_t lp_ip;
+  uint16_t action_offset;
+  while (ptr < end) {
+    uint16_t ip_start;
+    ptr += uleb(ptr, &ip_start);
+    uint16_t ip_range;
+    ptr += uleb(ptr, &ip_range);
+    ptr += uleb(ptr, &lp_ip);
+    ptr += uleb(ptr, &action_offset);
+    if (ip_start < pc_offset && pc_offset <= ip_start + ip_range) {
+      out->landing_pad = lp_ip;
+      goto found_handler;
+    }
+  }
+  __avr_terminate();
+found_handler:
+  if (action_offset == 0) {
+    return 0;
+  }
+  ptr = end + action_offset - 1;
+  while (1) {
+    int16_t action, offset;
+    ptr += sleb(ptr, &action);
+    sleb(ptr, &offset);
+    ptr += offset;
+    if (action != 0) {
+      void *catch_type = getw(&type_table[-1 * action]);
+      if (catch_type == 0) // if it is a catch(...) block, match anything
+        return action;
+      void *ptr = get_adjusted_ptr(exc, catch_type);
+      if (ptr) {
+        return action;
+      }
+    } else {
+      return 0;
+    }
+    if (offset == 0)
+      break;
+  }
+  __avr_terminate();
+}
+
+}
+#endif
diff --git a/libstdc++-v3/libsupc++/eh_personality.cc b/libstdc++-v3/libsupc++/eh_personality.cc
index 12391e563d6..91f7825d7cb 100644
--- a/libstdc++-v3/libsupc++/eh_personality.cc
+++ b/libstdc++-v3/libsupc++/eh_personality.cc
@@ -333,406 +333,6 @@ empty_exception_spec (lsda_header_info *info, _Unwind_Sword filter_value)
 namespace __cxxabiv1
 {
 
-// Using a different personality function name causes link failures
-// when trying to mix code using different exception handling models.
-#ifdef __USING_SJLJ_EXCEPTIONS__
-#define PERSONALITY_FUNCTION	__gxx_personality_sj0
-#define __builtin_eh_return_data_regno(x) x
-#elif defined(__SEH__)
-#define PERSONALITY_FUNCTION	__gxx_personality_imp
-#else
-#define PERSONALITY_FUNCTION	__gxx_personality_v0
-#endif
-
-#if defined (__SEH__) && !defined (__USING_SJLJ_EXCEPTIONS__)
-static
-#else
-extern "C"
-#endif
-_Unwind_Reason_Code
-#ifdef __ARM_EABI_UNWINDER__
-__attribute__((target ("general-regs-only")))
-PERSONALITY_FUNCTION (_Unwind_State state,
-		      struct _Unwind_Exception* ue_header,
-		      struct _Unwind_Context* context)
-#else
-PERSONALITY_FUNCTION (int version,
-		      _Unwind_Action actions,
-		      _Unwind_Exception_Class exception_class,
-		      struct _Unwind_Exception *ue_header,
-		      struct _Unwind_Context *context)
-#endif
-{
-  enum found_handler_type
-  {
-    found_nothing,
-    found_terminate,
-    found_cleanup,
-    found_handler
-  } found_type;
-
-  lsda_header_info info;
-  const unsigned char *language_specific_data;
-  const unsigned char *action_record;
-  const unsigned char *p;
-  _Unwind_Ptr landing_pad, ip;
-  int handler_switch_value;
-  void* thrown_ptr = 0;
-  bool foreign_exception;
-  int ip_before_insn = 0;
-
-#ifdef __ARM_EABI_UNWINDER__
-  _Unwind_Action actions;
-
-  switch (state & _US_ACTION_MASK)
-    {
-    case _US_VIRTUAL_UNWIND_FRAME:
-      // If the unwind state pattern is
-      // _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
-      // then we don't need to search for any handler as it is not a real
-      // exception. Just unwind the stack.
-      if (state & _US_FORCE_UNWIND)
-	CONTINUE_UNWINDING;
-      actions = _UA_SEARCH_PHASE;
-      break;
-
-    case _US_UNWIND_FRAME_STARTING:
-      actions = _UA_CLEANUP_PHASE;
-      if (!(state & _US_FORCE_UNWIND)
-	  && ue_header->barrier_cache.sp == _Unwind_GetGR(context,
-							  UNWIND_STACK_REG))
-	actions |= _UA_HANDLER_FRAME;
-      break;
-
-    case _US_UNWIND_FRAME_RESUME:
-      CONTINUE_UNWINDING;
-      break;
-
-    default:
-      std::abort();
-    }
-  actions |= state & _US_FORCE_UNWIND;
-
-  // We don't know which runtime we're working with, so can't check this.
-  // However the ABI routines hide this from us, and we don't actually need
-  // to know.
-  foreign_exception = false;
-
-  // The dwarf unwinder assumes the context structure holds things like the
-  // function and LSDA pointers.  The ARM implementation caches these in
-  // the exception header (UCB).  To avoid rewriting everything we make a
-  // virtual scratch register point at the UCB.
-  ip = (_Unwind_Ptr) ue_header;
-  _Unwind_SetGR(context, UNWIND_POINTER_REG, ip);
-#else
-  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);
-
-  // Interface version check.
-  if (version != 1)
-    return _URC_FATAL_PHASE1_ERROR;
-  foreign_exception = !__is_gxx_exception_class(exception_class);
-#endif
-
-  // Shortcut for phase 2 found handler for domestic exception.
-  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)
-      && !foreign_exception)
-    {
-      restore_caught_exception(ue_header, handler_switch_value,
-			       language_specific_data, landing_pad);
-      found_type = (landing_pad == 0 ? found_terminate : found_handler);
-      goto install_context;
-    }
-
-  language_specific_data = (const unsigned char *)
-    _Unwind_GetLanguageSpecificData (context);
-
-  // If no LSDA, then there are no handlers or cleanups.
-  if (! language_specific_data)
-    CONTINUE_UNWINDING;
-
-  // Parse the LSDA header.
-  p = parse_lsda_header (context, language_specific_data, &info);
-  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);
-#ifdef _GLIBCXX_HAVE_GETIPINFO
-  ip = _Unwind_GetIPInfo (context, &ip_before_insn);
-#else
-  ip = _Unwind_GetIP (context);
-#endif
-  if (! ip_before_insn)
-    --ip;
-  landing_pad = 0;
-  action_record = 0;
-  handler_switch_value = 0;
-
-#ifdef __USING_SJLJ_EXCEPTIONS__
-  // The given "IP" is an index into the call-site table, with two
-  // exceptions -- -1 means no-action, and 0 means terminate.  But
-  // since we're using uleb128 values, we've not got random access
-  // to the array.
-  if ((int) ip < 0)
-    return _URC_CONTINUE_UNWIND;
-  else if (ip == 0)
-    {
-      // Fall through to set found_terminate.
-    }
-  else
-    {
-      _uleb128_t cs_lp, cs_action;
-      do
-	{
-	  p = read_uleb128 (p, &cs_lp);
-	  p = read_uleb128 (p, &cs_action);
-	}
-      while (--ip);
-
-      // Can never have null landing pad for sjlj -- that would have
-      // been indicated by a -1 call site index.
-      landing_pad = cs_lp + 1;
-      if (cs_action)
-	action_record = info.action_table + cs_action - 1;
-      goto found_something;
-    }
-#else
-  // Search the call-site table for the action associated with this IP.
-  while (p < info.action_table)
-    {
-      _Unwind_Ptr cs_start, cs_len, cs_lp;
-      _uleb128_t cs_action;
-
-      // Note that all call-site encodings are "absolute" displacements.
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);
-      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);
-      p = read_uleb128 (p, &cs_action);
-
-      // The table is sorted, so if we've passed the ip, stop.
-      if (ip < info.Start + cs_start)
-	p = info.action_table;
-      else if (ip < info.Start + cs_start + cs_len)
-	{
-	  if (cs_lp)
-	    landing_pad = info.LPStart + cs_lp;
-	  if (cs_action)
-	    action_record = info.action_table + cs_action - 1;
-	  goto found_something;
-	}
-    }
-#endif // __USING_SJLJ_EXCEPTIONS__
-
-  // If ip is not present in the table, call terminate.  This is for
-  // a destructor inside a cleanup, or a library routine the compiler
-  // was not expecting to throw.
-  found_type = found_terminate;
-  goto do_something;
-
- found_something:
-  if (landing_pad == 0)
-    {
-      // If ip is present, and has a null landing pad, there are
-      // no cleanups or handlers to be run.
-      found_type = found_nothing;
-    }
-  else if (action_record == 0)
-    {
-      // If ip is present, has a non-null landing pad, and a null
-      // action table offset, then there are only cleanups present.
-      // Cleanups use a zero switch value, as set above.
-      found_type = found_cleanup;
-    }
-  else
-    {
-      // Otherwise we have a catch handler or exception specification.
-
-      _sleb128_t ar_filter, ar_disp;
-      const std::type_info* catch_type;
-      _throw_typet* throw_type;
-      bool saw_cleanup = false;
-      bool saw_handler = false;
-
-#ifdef __ARM_EABI_UNWINDER__
-      // ??? How does this work - more importantly, how does it interact with
-      // dependent exceptions?
-      throw_type = ue_header;
-      if (actions & _UA_FORCE_UNWIND)
-	{
-	  __GXX_INIT_FORCED_UNWIND_CLASS(ue_header->exception_class);
-	}
-      else if (!foreign_exception)
-	thrown_ptr = __get_object_from_ue (ue_header);
-#else
-#if __cpp_rtti
-      // During forced unwinding, match a magic exception type.
-      if (actions & _UA_FORCE_UNWIND)
-	{
-	  throw_type = &typeid(abi::__forced_unwind);
-	}
-      // With a foreign exception class, there's no exception type.
-      // ??? What to do about GNU Java and GNU Ada exceptions?
-      else if (foreign_exception)
-	{
-	  throw_type = &typeid(abi::__foreign_exception);
-	}
-      else
-#endif
-        {
-          thrown_ptr = __get_object_from_ue (ue_header);
-          throw_type = __get_exception_header_from_obj
-            (thrown_ptr)->exceptionType;
-        }
-#endif
-
-      while (1)
-	{
-	  p = action_record;
-	  p = read_sleb128 (p, &ar_filter);
-	  read_sleb128 (p, &ar_disp);
-
-	  if (ar_filter == 0)
-	    {
-	      // Zero filter values are cleanups.
-	      saw_cleanup = true;
-	    }
-	  else if (ar_filter > 0)
-	    {
-	      // Positive filter values are handlers.
-	      catch_type = get_ttype_entry (&info, ar_filter);
-
-	      // Null catch type is a catch-all handler; we can catch foreign
-	      // exceptions with this.  Otherwise we must match types.
-	      if (! catch_type
-		  || (throw_type
-		      && get_adjusted_ptr (catch_type, throw_type,
-					   &thrown_ptr)))
-		{
-		  saw_handler = true;
-		  break;
-		}
-	    }
-	  else
-	    {
-	      // Negative filter values are exception specifications.
-	      // ??? How do foreign exceptions fit in?  As far as I can
-	      // see we can't match because there's no __cxa_exception
-	      // object to stuff bits in for __cxa_call_unexpected to use.
-	      // Allow them iff the exception spec is non-empty.  I.e.
-	      // a throw() specification results in __unexpected.
-	      if ((throw_type
-		   && !(actions & _UA_FORCE_UNWIND)
-		   && !foreign_exception)
-		  ? ! check_exception_spec (&info, throw_type, thrown_ptr,
-					    ar_filter)
-		  : empty_exception_spec (&info, ar_filter))
-		{
-		  saw_handler = true;
-		  break;
-		}
-	    }
-
-	  if (ar_disp == 0)
-	    break;
-	  action_record = p + ar_disp;
-	}
-
-      if (saw_handler)
-	{
-	  handler_switch_value = ar_filter;
-	  found_type = found_handler;
-	}
-      else
-	found_type = (saw_cleanup ? found_cleanup : found_nothing);
-    }
-
- do_something:
-   if (found_type == found_nothing)
-     CONTINUE_UNWINDING;
-
-  if (actions & _UA_SEARCH_PHASE)
-    {
-      if (found_type == found_cleanup)
-	CONTINUE_UNWINDING;
-
-      // For domestic exceptions, we cache data from phase 1 for phase 2.
-      if (!foreign_exception)
-        {
-	  save_caught_exception(ue_header, context, thrown_ptr,
-				handler_switch_value, language_specific_data,
-				landing_pad, action_record);
-	}
-      return _URC_HANDLER_FOUND;
-    }
-
- install_context:
-  
-  // We can't use any of the cxa routines with foreign exceptions,
-  // because they all expect ue_header to be a struct __cxa_exception.
-  // So in that case, call terminate or unexpected directly.
-  if ((actions & _UA_FORCE_UNWIND)
-      || foreign_exception)
-    {
-      if (found_type == found_terminate)
-	std::terminate ();
-      else if (handler_switch_value < 0)
-	{
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-	  __try
-	    { std::unexpected (); }
-	  __catch(...)
-	    { std::terminate (); }
-#pragma GCC diagnostic pop
-	}
-    }
-  else
-    {
-      if (found_type == found_terminate)
-	__cxa_call_terminate(ue_header);
-
-      // Cache the TType base value for __cxa_call_unexpected, as we won't
-      // have an _Unwind_Context then.
-      if (handler_switch_value < 0)
-	{
-	  parse_lsda_header (context, language_specific_data, &info);
-	  info.ttype_base = base_of_encoded_value (info.ttype_encoding,
-						   context);
-
-#ifdef __ARM_EABI_UNWINDER__
-	  const _Unwind_Word* e;
-	  _Unwind_Word n;
-	  
-	  e = ((const _Unwind_Word*) info.TType) - handler_switch_value - 1;
-	  // Count the number of rtti objects.
-	  n = 0;
-	  while (e[n] != 0)
-	    n++;
-
-	  // Count.
-	  ue_header->barrier_cache.bitpattern[1] = n;
-	  // Base
-	  ue_header->barrier_cache.bitpattern[2] = info.ttype_base;
-	  // Stride.
-	  ue_header->barrier_cache.bitpattern[3] = 4;
-	  // List head.
-	  ue_header->barrier_cache.bitpattern[4] = (_Unwind_Word) e;
-#else
-	  xh->catchTemp = base_of_encoded_value (info.ttype_encoding, context);
-#endif
-	}
-    }
-
-  /* For targets with pointers smaller than the word size, we must extend the
-     pointer, and this extension is target dependent.  */
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),
-		 __builtin_extend_pointer (ue_header));
-  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),
-		 handler_switch_value);
-  _Unwind_SetIP (context, landing_pad);
-#ifdef __ARM_EABI_UNWINDER__
-  if (found_type == found_cleanup)
-    __cxa_begin_cleanup(ue_header);
-#endif
-  return _URC_INSTALL_CONTEXT;
-}
-
 /* The ARM EABI implementation of __cxa_call_unexpected is in a
    different file so that the personality routine (PR) can be used
    standalone.  The generic routine shared datastructures with the PR
diff --git a/libstdc++-v3/src/c++98/math_stubs_long_double.cc b/libstdc++-v3/src/c++98/math_stubs_long_double.cc
index b964ea23be2..d63626088e3 100644
--- a/libstdc++-v3/src/c++98/math_stubs_long_double.cc
+++ b/libstdc++-v3/src/c++98/math_stubs_long_double.cc
@@ -30,195 +30,195 @@
 
 extern "C"
 {
-#ifndef _GLIBCXX_HAVE_FABSL
-  long double
-  fabsl(long double x)
-  {
-    return fabs((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ACOSL
-  long double
-  acosl(long double x)
-  {
-    return acos((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ASINL
-  long double
-  asinl(long double x)
-  {
-    return asin((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ATANL
-  long double
-  atanl(long double x)
-  {
-    return atan ((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_ATAN2L
-  long double
-  atan2l(long double x, long double y)
-  {
-    return atan2((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_CEILL
-  long double
-  ceill(long double x)
-  {
-    return ceil((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_COSL
-  long double
-  cosl(long double x)
-  {
-    return cos((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_COSHL
-  long double
-  coshl(long double x)
-  {
-    return cosh((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_EXPL
-  long double
-  expl(long double x)
-  {
-    return exp((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FLOORL
-  long double
-  floorl(long double x)
-  {
-    return floor((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FMODL
-  long double
-  fmodl(long double x, long double y)
-  {
-    return fmod((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_FREXPL
-  long double
-  frexpl(long double x, int *exp)
-  {
-    return frexp((double) x, exp);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SQRTL
-  long double
-  sqrtl(long double x)
-  {
-    return  sqrt((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_HYPOTL
-  long double
-  hypotl(long double x, long double y)
-  {
-    long double s = fabsl(x) + fabsl(y);
-    if (s == 0.0L)
-      return s;
-    x /= s; y /= s;
-    return s * sqrtl(x * x + y * y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LDEXPL
-  long double
-  ldexpl(long double x, int exp)
-  {
-    return ldexp((double) x, exp);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LOGL
-  long double
-  logl(long double x)
-  {
-    return log((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_LOG10L
-  long double
-  log10l(long double x)
-  {
-    return log10((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_MODFL
-  long double
-  modfl(long double x, long double *iptr)
-  {
-    double result, temp;
-
-    result = modf((double) x, &temp);
-    *iptr = temp;
-    return result;
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_POWL
-  long double
-  powl(long double x, long double y)
-  {
-    return pow((double) x, (double) y);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SINL
-  long double
-  sinl(long double x)
-  {
-    return sin((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_SINHL
-  long double
-  sinhl(long double x)
-  {
-    return sinh((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_TANL
-  long double
-  tanl(long double x)
-  {
-    return tan((double) x);
-  }
-#endif
-
-#ifndef _GLIBCXX_HAVE_TANHL
-  long double
-  tanhl(long double x)
-  {
-    return tanh((double) x);
-  }
-#endif
+// #ifndef _GLIBCXX_HAVE_FABSL
+//   long double
+//   fabsl(long double x)
+//   {
+//     return fabs((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ACOSL
+//   long double
+//   acosl(long double x)
+//   {
+//     return acos((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ASINL
+//   long double
+//   asinl(long double x)
+//   {
+//     return asin((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ATANL
+//   long double
+//   atanl(long double x)
+//   {
+//     return atan ((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_ATAN2L
+//   long double
+//   atan2l(long double x, long double y)
+//   {
+//     return atan2((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_CEILL
+//   long double
+//   ceill(long double x)
+//   {
+//     return ceil((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_COSL
+//   long double
+//   cosl(long double x)
+//   {
+//     return cos((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_COSHL
+//   long double
+//   coshl(long double x)
+//   {
+//     return cosh((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_EXPL
+//   long double
+//   expl(long double x)
+//   {
+//     return exp((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FLOORL
+//   long double
+//   floorl(long double x)
+//   {
+//     return floor((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FMODL
+//   long double
+//   fmodl(long double x, long double y)
+//   {
+//     return fmod((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_FREXPL
+//   long double
+//   frexpl(long double x, int *exp)
+//   {
+//     return frexp((double) x, exp);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SQRTL
+//   long double
+//   sqrtl(long double x)
+//   {
+//     return  sqrt((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_HYPOTL
+//   long double
+//   hypotl(long double x, long double y)
+//   {
+//     long double s = fabsl(x) + fabsl(y);
+//     if (s == 0.0L)
+//       return s;
+//     x /= s; y /= s;
+//     return s * sqrtl(x * x + y * y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LDEXPL
+//   long double
+//   ldexpl(long double x, int exp)
+//   {
+//     return ldexp((double) x, exp);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LOGL
+//   long double
+//   logl(long double x)
+//   {
+//     return log((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_LOG10L
+//   long double
+//   log10l(long double x)
+//   {
+//     return log10((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_MODFL
+//   long double
+//   modfl(long double x, long double *iptr)
+//   {
+//     double result, temp;
+
+//     result = modf((double) x, &temp);
+//     *iptr = temp;
+//     return result;
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_POWL
+//   long double
+//   powl(long double x, long double y)
+//   {
+//     return pow((double) x, (double) y);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SINL
+//   long double
+//   sinl(long double x)
+//   {
+//     return sin((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_SINHL
+//   long double
+//   sinhl(long double x)
+//   {
+//     return sinh((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_TANL
+//   long double
+//   tanl(long double x)
+//   {
+//     return tan((double) x);
+//   }
+// #endif
+
+// #ifndef _GLIBCXX_HAVE_TANHL
+//   long double
+//   tanhl(long double x)
+//   {
+//     return tanh((double) x);
+//   }
+// #endif
 } // extern "C"
-- 
2.50.0


From 3958df99f7458ec370a93e4197937e2514647e37 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sun, 3 Nov 2024 15:06:08 -0800
Subject: [PATCH 02/11] __avr_terminate causes a dependency loop, so it had to
 be changed

TODO: make c++ change avr_terminate_ptr to actually call terminate_handler.
---
 libgcc/config/avr/unwind-avr-sup.c | 13 ++++++++++++-
 libstdc++-v3/libsupc++/eh_avr.cc   |  4 ----
 2 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/libgcc/config/avr/unwind-avr-sup.c b/libgcc/config/avr/unwind-avr-sup.c
index 694d684b879..a2192865352 100644
--- a/libgcc/config/avr/unwind-avr-sup.c
+++ b/libgcc/config/avr/unwind-avr-sup.c
@@ -5,7 +5,18 @@ extern prog_byte __fae_table_stop[];
 
 typedef const table_entry_t __maybe_flash * table_ptr;
 
-void __avr_terminate() __attribute__((noreturn));
+typedef void (*__avr_terminate_handler_t)() __attribute__((noreturn));
+
+static __attribute__((noreturn)) void __avr_terminate_default_impl(){
+  volatile char c = 0;
+  while(1) {c = 0;}
+}
+
+__avr_terminate_handler_t __avr_terminate_ptr = &__avr_terminate_default_impl;
+
+void __avr_terminate() __attribute__((noreturn)){
+  __avr_terminate_ptr();
+}
 // no plans to implement forced unwinding
 void _Unwind_ForcedUnwind() { __avr_terminate(); }
 
diff --git a/libstdc++-v3/libsupc++/eh_avr.cc b/libstdc++-v3/libsupc++/eh_avr.cc
index 152fb0e4660..a658d89b88b 100644
--- a/libstdc++-v3/libsupc++/eh_avr.cc
+++ b/libstdc++-v3/libsupc++/eh_avr.cc
@@ -42,10 +42,6 @@ static void *get_adjusted_ptr(void *exc,
   return cxa_except->adjustedPtr;
 }
 
-extern "C" void __avr_terminate() {
-  std::terminate();
-}
-
 typedef const uint8_t prog_byte;
 typedef void* void_ptr;
 typedef const void_ptr *prog_ptr;
-- 
2.50.0


From 7fe63aa510baa2a55e342c688bec490adb21500b Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sun, 3 Nov 2024 15:36:10 -0800
Subject: [PATCH 03/11] fix attribute order

---
 libgcc/config/avr/unwind-avr-sup.c | 2 +-
 libstdc++-v3/libsupc++/eh_avr.cc   | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/libgcc/config/avr/unwind-avr-sup.c b/libgcc/config/avr/unwind-avr-sup.c
index a2192865352..a9b65f9436f 100644
--- a/libgcc/config/avr/unwind-avr-sup.c
+++ b/libgcc/config/avr/unwind-avr-sup.c
@@ -14,7 +14,7 @@ static __attribute__((noreturn)) void __avr_terminate_default_impl(){
 
 __avr_terminate_handler_t __avr_terminate_ptr = &__avr_terminate_default_impl;
 
-void __avr_terminate() __attribute__((noreturn)){
+__attribute__((noreturn)) void __avr_terminate() {
   __avr_terminate_ptr();
 }
 // no plans to implement forced unwinding
diff --git a/libstdc++-v3/libsupc++/eh_avr.cc b/libstdc++-v3/libsupc++/eh_avr.cc
index a658d89b88b..6eda3e48cd6 100644
--- a/libstdc++-v3/libsupc++/eh_avr.cc
+++ b/libstdc++-v3/libsupc++/eh_avr.cc
@@ -93,6 +93,7 @@ struct personality_out{
   uint16_t landing_pad;
 };
 
+extern "C" __attribute__((noreturn)) void __avr_terminate();
 
 // this is very bad, and probably should be rewritten in assembly for speed/size
 extern "C" uint8_t __avr_cxx_personality(prog_byte *ptr, uint16_t pc_offset, void *exc,
-- 
2.50.0


From b43e6d9daf00d462cb81cd61bed43c89914e6da6 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sun, 3 Nov 2024 18:52:27 -0800
Subject: [PATCH 04/11] fix LIB2ADDEH override to include default sources

---
 libgcc/config/avr/t-avr | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libgcc/config/avr/t-avr b/libgcc/config/avr/t-avr
index 0335608a4bb..681b65bc125 100644
--- a/libgcc/config/avr/t-avr
+++ b/libgcc/config/avr/t-avr
@@ -295,4 +295,4 @@ LIB2FUNCS_EXCLUDE += \
 	$(foreach func,_ssmul,\
 	$(foreach mode,$(ssmul_modes),$(func_X)))
 
-LIB2ADDEH = $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
+LIB2ADDEH += $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
-- 
2.50.0


From f05f79a1a00cd6c360a2737c958da70bcdeeb2c9 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sun, 3 Nov 2024 22:00:58 -0800
Subject: [PATCH 05/11] Add weak to unwind symbols so that config overrides it

---
 gcc/config/avr/avr.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 3c5da955dd8..afe700bfee3 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -40,6 +40,11 @@ typedef struct
   const char *section_name;
 } avr_addrspace_t;
 
+
+/* This has to be done so that unwind-avr.S overrides the definition
+   defined in unwind.inc. */
+#define LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
+
 extern const avr_addrspace_t avr_addrspace[];
 
 /* Known address spaces */
-- 
2.50.0


From d7e2c56e6df9df4bf1c664415b1b927a4ae064cd Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Fri, 8 Nov 2024 17:48:56 -0800
Subject: [PATCH 06/11] Revert "Add weak to unwind symbols so that config
 overrides it"

This reverts commit 6f4d77c6ce69dde1ad0caf05b236b5958a488666.
As it turns out there's a better way to do this.
---
 gcc/config/avr/avr.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index afe700bfee3..3c5da955dd8 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -40,11 +40,6 @@ typedef struct
   const char *section_name;
 } avr_addrspace_t;
 
-
-/* This has to be done so that unwind-avr.S overrides the definition
-   defined in unwind.inc. */
-#define LIBGCC2_UNWIND_ATTRIBUTE __attribute__((weak))
-
 extern const avr_addrspace_t avr_addrspace[];
 
 /* Known address spaces */
-- 
2.50.0


From a4ea0e9745e624e81ae2ebf41326ded4268d8d3d Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Fri, 8 Nov 2024 17:49:46 -0800
Subject: [PATCH 07/11] define _Unwind_DeleteException in unwind-avr-sup.c

ok so as it turns out before because I defined DeleteException as inline,
which made it work before. Now I'm defining it as a seperate function.
Doing it this way increases binary bloat, but better conforms to the
itanium abi. Later I'll figure out a way to reduce the exception handling
ABI, but for now just put it in unwind-avr-sup.c
---
 libgcc/config/avr/t-avr            |  2 +-
 libgcc/config/avr/unwind-avr-sup.c | 13 +++++++++++--
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/libgcc/config/avr/t-avr b/libgcc/config/avr/t-avr
index 681b65bc125..0335608a4bb 100644
--- a/libgcc/config/avr/t-avr
+++ b/libgcc/config/avr/t-avr
@@ -295,4 +295,4 @@ LIB2FUNCS_EXCLUDE += \
 	$(foreach func,_ssmul,\
 	$(foreach mode,$(ssmul_modes),$(func_X)))
 
-LIB2ADDEH += $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
+LIB2ADDEH = $(srcdir)/config/avr/unwind-avr.S $(srcdir)/config/avr/unwind-avr-sup.c
diff --git a/libgcc/config/avr/unwind-avr-sup.c b/libgcc/config/avr/unwind-avr-sup.c
index a9b65f9436f..c2625c6ab0f 100644
--- a/libgcc/config/avr/unwind-avr-sup.c
+++ b/libgcc/config/avr/unwind-avr-sup.c
@@ -1,4 +1,5 @@
 #include "fae.h"
+#include "unwind-generic.h"
 
 extern prog_byte __fae_table_start[];
 extern prog_byte __fae_table_stop[];
@@ -8,8 +9,7 @@ typedef const table_entry_t __maybe_flash * table_ptr;
 typedef void (*__avr_terminate_handler_t)() __attribute__((noreturn));
 
 static __attribute__((noreturn)) void __avr_terminate_default_impl(){
-  volatile char c = 0;
-  while(1) {c = 0;}
+  __builtin_trap();
 }
 
 __avr_terminate_handler_t __avr_terminate_ptr = &__avr_terminate_default_impl;
@@ -17,6 +17,15 @@ __avr_terminate_handler_t __avr_terminate_ptr = &__avr_terminate_default_impl;
 __attribute__((noreturn)) void __avr_terminate() {
   __avr_terminate_ptr();
 }
+
+void
+_Unwind_DeleteException (struct _Unwind_Exception *exc)
+{
+  if (exc->exception_cleanup)
+    (*exc->exception_cleanup) (_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
+}
+
+
 // no plans to implement forced unwinding
 void _Unwind_ForcedUnwind() { __avr_terminate(); }
 
-- 
2.50.0


From c4443481f330f42d2201ec7aec4c4783401cde73 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Fri, 8 Nov 2024 18:08:39 -0800
Subject: [PATCH 08/11] fixed function signature of _Unwind_ForcedUnwind

---
 libgcc/config/avr/unwind-avr-sup.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libgcc/config/avr/unwind-avr-sup.c b/libgcc/config/avr/unwind-avr-sup.c
index c2625c6ab0f..75b7d8ec917 100644
--- a/libgcc/config/avr/unwind-avr-sup.c
+++ b/libgcc/config/avr/unwind-avr-sup.c
@@ -27,7 +27,7 @@ _Unwind_DeleteException (struct _Unwind_Exception *exc)
 
 
 // no plans to implement forced unwinding
-void _Unwind_ForcedUnwind() { __avr_terminate(); }
+_Unwind_Reason_Code _Unwind_ForcedUnwind(struct _Unwind_Exception *, _Unwind_Stop_Fn, void *) { __avr_terminate(); }
 
 // returns data pointer for pc entry. If no entry is found, return 0
 table_data __fae_get_ptr(void *except, uint16_t pc) {
-- 
2.50.0


From 77202658687c343737c9a53692ede5ec2cbd68f3 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Fri, 27 Jun 2025 12:32:31 -0700
Subject: [PATCH 09/11] hopefully generates .handlerdata and .personality
 correctly

---
 gcc/config/avr/avr-protos.h |  1 +
 gcc/config/avr/avr.cc       | 22 ++++++++++++++++------
 gcc/config/avr/avr.h        |  1 +
 gcc/defaults.h              |  5 +++++
 gcc/except.cc               |  1 +
 5 files changed, 24 insertions(+), 6 deletions(-)

diff --git a/gcc/config/avr/avr-protos.h b/gcc/config/avr/avr-protos.h
index 242946b87a4..a1a43ad3952 100644
--- a/gcc/config/avr/avr-protos.h
+++ b/gcc/config/avr/avr-protos.h
@@ -89,6 +89,7 @@ extern rtx avr_to_int_mode (rtx);
 extern void avr_expand_prologue (void);
 extern void avr_expand_epilogue (bool);
 extern rtx avr_eh_return_handler_rtx (void);
+extern void avr_output_handlerdata(void);
 extern bool avr_emit_cpymemhi (rtx*);
 extern int avr_epilogue_uses (int regno);
 
diff --git a/gcc/config/avr/avr.cc b/gcc/config/avr/avr.cc
index 488e52f6a5d..f3098285c20 100644
--- a/gcc/config/avr/avr.cc
+++ b/gcc/config/avr/avr.cc
@@ -1517,8 +1517,14 @@ avr_output_fn_unwind (FILE * f, bool prologue)
     && (TREE_NOTHROW (current_function_decl)
         || crtl->all_throwers_are_sibcalls))
   fputs("\t.cantunwind\n", f);
-      fputs ("\t.fnstart\n", f);}
-  else
+      fputs ("\t.fnstart\n", f);
+
+ if(crtl->uses_eh_lsda)
+        fputs("\t.personality\t__avr_cxx_personality\n", f);
+
+  }
+
+       else
     {
      
 
@@ -1526,6 +1532,12 @@ avr_output_fn_unwind (FILE * f, bool prologue)
     }
 }
 
+
+#define EH_LSDA_POST avr_output_handlerdata()
+void avr_output_handlerdata(void){
+  output_section_asm_op(".handlerdata\n");
+}
+
 /*  Emit unwind directives for a SET.  */
 
 static void
@@ -10989,7 +11001,7 @@ avr_output_bss_section_asm_op (const char *data)
   avr_need_clear_bss_p = true;
 
   /* Dispatch to default.  */
-  output_section_asm_op (data);
+  output_section_asm_op  (data);
 }
 
 
@@ -11055,14 +11067,12 @@ avr_output_addr_attrib (tree decl, const char *name,
 
 
 /* Implement `TARGET_ASM_INIT_SECTIONS'.  */
-
 static void
 avr_asm_init_sections (void)
 {
   /* Override section callbacks to keep track of `avr_need_clear_bss_p'
      resp. `avr_need_copy_data_p'.  If flash is not mapped to RAM then
-     we have also to track .rodata because it is located in RAM then.  */
-
+     we have also to track .rodata because it is located in RAM then.  */ 
 #if defined HAVE_LD_AVR_AVRXMEGA3_RODATA_IN_FLASH
   if (avr_arch->flash_pm_offset == 0)
 #endif
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
index 3c5da955dd8..d5a2faf23f1 100644
--- a/gcc/config/avr/avr.h
+++ b/gcc/config/avr/avr.h
@@ -535,6 +535,7 @@ extern const char *avr_no_devlib (int, const char**);
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)           (DW_EH_PE_absptr)
 #define EH_RETURN_HANDLER_RTX avr_eh_return_handler_rtx ()
 
+#define EH_LSDA_POST avr_output_handlerdata ()
 
 #define DWARF2_ADDR_SIZE 4
 
diff --git a/gcc/defaults.h b/gcc/defaults.h
index dc6f09cacae..068ce278d80 100644
--- a/gcc/defaults.h
+++ b/gcc/defaults.h
@@ -393,6 +393,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define EH_RETURN_DATA_REGNO(N) INVALID_REGNUM
 #endif
 
+/* A hook for adding stuff after the LSDA section has been switched to */
+#ifndef EH_LSDA_POST
+#define EH_LSDA_POST
+#endif
+
 /* Offset between the eh handler address and entry in eh tables.  */
 #ifndef RETURN_ADDR_OFFSET
 #define RETURN_ADDR_OFFSET 0
diff --git a/gcc/except.cc b/gcc/except.cc
index e728aa43b6a..76e6d124339 100644
--- a/gcc/except.cc
+++ b/gcc/except.cc
@@ -2952,6 +2952,7 @@ switch_to_exception_section (const char * ARG_UNUSED (fnname))
     }
 
   switch_to_section (s);
+  EH_LSDA_POST;
 }
 
 /* Output a reference from an exception table to the type_info object TYPE.
-- 
2.50.0


From 2a923ccbfffc856b4621b5d07462cabfbac5a744 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Sat, 28 Jun 2025 22:05:51 -0700
Subject: [PATCH 10/11] mark avr_cxx_personality as used so LTO doesn't
 eliminate it

---
 libstdc++-v3/libsupc++/eh_avr.cc | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libstdc++-v3/libsupc++/eh_avr.cc b/libstdc++-v3/libsupc++/eh_avr.cc
index 6eda3e48cd6..a2727789677 100644
--- a/libstdc++-v3/libsupc++/eh_avr.cc
+++ b/libstdc++-v3/libsupc++/eh_avr.cc
@@ -96,6 +96,7 @@ struct personality_out{
 extern "C" __attribute__((noreturn)) void __avr_terminate();
 
 // this is very bad, and probably should be rewritten in assembly for speed/size
+__attribute__((__used__))
 extern "C" uint8_t __avr_cxx_personality(prog_byte *ptr, uint16_t pc_offset, void *exc,
                            personality_out *out) noexcept {
   uint8_t lp_encoding = get(ptr++);
-- 
2.50.0


From dd5ff9521264e57600c705ceee47bdb5ab146745 Mon Sep 17 00:00:00 2001
From: Shin Umeda <umeda.shin@gmail.com>
Date: Thu, 3 Jul 2025 10:38:33 -0700
Subject: [PATCH 11/11] For now, I'm giving up on exceptions.

Maybe somebody else with more time can try this. Just revert
this commit and debug it for yourself. For now, I'd like to
move on to other projects.
---
 gcc/config/avr/specs.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/config/avr/specs.h b/gcc/config/avr/specs.h
index 1a4fdb9c0b5..2610eaa8541 100644
--- a/gcc/config/avr/specs.h
+++ b/gcc/config/avr/specs.h
@@ -40,9 +40,9 @@ along with GCC; see the file COPYING3.  If not see
 #undef  CC1PLUS_SPEC
 #define CC1PLUS_SPEC                                    \
   "%(cc1) "                                             \
-  "%{!frtti:-frtti} "                                \
+  "%{!frtti:-fno-rtti} "                                \
   "%{!fenforce-eh-specs:-fno-enforce-eh-specs} "        \
-  "%{!fexceptions:-fexceptions} "
+  "%{!fexceptions:-fno-exceptions} "
 
 #define ASM_RELAX_SPEC                          \
   "%{mrelax:--mlink-relax} "
-- 
2.50.0

